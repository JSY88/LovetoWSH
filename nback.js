 // Web Audio Context Initialization
const audioContext = new (window.AudioContext || window.webkitAudioContext)();


let nearMissHistory = []; // Ï†ÑÏó≠ Î≥ÄÏàò: ÎãàÏñºÎØ∏Ïä§ Ïù¥Î≤§Ìä∏(ÌÉÄÍ≤ü ÏïÑÎãå ÏûêÍ∑πÏóê ÎåÄÌïú Ïò§Î∞òÏùë Ï∂îÏ†Å)Î•º Í∏∞Î°ùÌïòÎäî Î∞∞Ïó¥



const roomWidth = 5;
const roomHeight = 3;
const roomDepth = 5;
const panelDepth = 0.02;

const panelPositions = [
    { x: -1.3, y: 1.9, z: -roomDepth / 2 + 0.06, rotation: [0, 0, 0] },
    { x: 1.3, y: 1.9, z: -roomDepth / 2 + 0.06, rotation: [0, 0, 0] },
    { x: -1.3, y: 0.8, z: -roomDepth / 2 + 0.06, rotation: [0, 0, 0] },
    { x: 1.3, y: 0.8, z: -roomDepth / 2 + 0.06, rotation: [0, 0, 0] },
    { x: -roomWidth / 2 + 0.06, y: 1.9, z: -0.5, rotation: [0, Math.PI / 2, 0] },
    { x: -roomWidth / 2 + 0.06, y: 0.8, z: -0.5, rotation: [0, Math.PI / 2, 0] },
    { x: roomWidth / 2 - 0.06, y: 1.9, z: -0.5, rotation: [0, -Math.PI / 2, 0] },
    { x: roomWidth / 2 - 0.06, y: 0.8, z: -0.5, rotation: [0, -Math.PI / 2, 0] },
    { x: -1.3, y: roomHeight - panelDepth / 2, z: -0.25, rotation: [Math.PI / 2, 0, 0] }, // Ï≤úÏû• 1: Ï≤úÏû• Î©¥Ïóê ÌèâÌñâ
    { x: 1.3, y: roomHeight - panelDepth / 2, z: -0.25, rotation: [Math.PI / 2, 0, 0] }, // Ï≤úÏû• 2: Ï≤úÏû• Î©¥Ïóê ÌèâÌñâ
    { x: -1.3, y: panelDepth / 2, z: -0.48, rotation: [-Math.PI / 2, 0, 0] }, // Î∞îÎã• 1: Î∞îÎã• Î©¥Ïóê ÌèâÌñâ
    { x: 1.3, y: panelDepth / 2, z: -0.48, rotation: [-Math.PI / 2, 0, 0] }  // Î∞îÎã• 2: Î∞îÎã• Î©¥Ïóê ÌèâÌñâ
];





// Game State
const gameState = {
    stimulusDuration: 1000,      // ÏûêÍ∑π Ï†úÏãú ÏßÄÏÜçÏãúÍ∞Ñ (ms)
    stimulusInterval: 2500,      // ÏûêÍ∑π Í∞Ñ Í∞ÑÍ≤© ÏãúÍ∞Ñ (ms)
    isPlaying: false,
    nBackLevel: 1,
    currentBlock: 0,
    maxBlocks: 12,
    stimuliPerBlock: 30,
    currentStimulus: 0,
    sceneHistory: [],
    locationHistory: [],
    soundHistory: [],
    colorHistory: [],
buttonStyles: null, // Î≤ÑÌäº Ïä§ÌÉÄÏùº Ï†ÄÏû•Ïö© ÏÜçÏÑ± Ï∂îÍ∞Ä
accuracyHistory: [], // Ï†ïÌôïÎèÑ Í∏∞Î°ù Î∞∞Ïó¥ Ï∂îÍ∞Ä
nearMissProbability: 0.3, // ÎãàÏñºÎØ∏Ïä§ Î∞úÏÉù ÌôïÎ•† (Í∏∞Î≥∏ 10%)
    nearMissResponses: 0,     // ÎãàÏñºÎØ∏Ïä§Ïóê Î∞òÏùëÌïú ÌöüÏàò
    targetMissedErrors: { scene: 0, location: 0, sound: 0, color: 0 }, // ÌÉÄÍ≤üÏù∏Îç∞ Ïò§Îãµ Ï≤òÎ¶¨Îêú ÌöüÏàò
    nonTargetFalseResponses: { scene: 0, location: 0, sound: 0, color: 0 }, // ÎÖºÌÉÄÍ≤üÏùÑ Ï†ïÎãµÏúºÎ°ú Ïò§ÌåêÏ†ïÌïú ÌöüÏàò
    sceneTargets: 0,
    locationTargets: 0,
    soundTargets: 0,
    colorTargets: 0,
    bothTargets: 0,
    canRespondScene: true,      // Scene ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä
    canRespondLocation: true,   // Location ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä
    canRespondSound: true,      // Sound ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä
    canRespondColor: true,      // Color ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä
    sceneResponses: 0,
    locationResponses: 0,
    soundResponses: 0,
    colorResponses: 0,
    sceneErrors: 0,
    locationErrors: 0,
    soundErrors: 0,
    colorErrors: 0,
    currentTimer: null,
    responseWindowTimer: null,
    sceneTargetProcessed: false,
    locationTargetProcessed: false,
    soundTargetProcessed: false,
    colorTargetProcessed: false,
    currentIsSceneTarget: false,
    currentIsLocationTarget: false,
    currentIsSoundTarget: false,
    currentIsColorTarget: false,
    inResponseWindow: false,
    canRespond: true,
    consecutiveGames: 0,
    totalGamesToday: 0,
    stimulusTypes: [],
    randomizeInterval: false, // Î¨¥ÏûëÏúÑ Í∞ÑÍ≤© Í∏∞Îä• ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
    minInterval: 1500,       // Î¨¥ÏûëÏúÑ Í∞ÑÍ≤©Ïùò ÏµúÏÜåÍ∞í (ms)
    maxInterval: 2500,       // Î¨¥ÏûëÏúÑ Í∞ÑÍ≤©Ïùò ÏµúÎåÄÍ∞í (ms)
    previousInterval: null,  // Ïù¥Ï†Ñ Í∞ÑÍ≤© ÏãúÍ∞Ñ Ï†ÄÏû•
    soundSource: "pianoTones",
    soundFiles: ['sounds/sound001.wav', 'sounds/sound002.wav', 'sounds/sound003.wav', 'sounds/sound004.wav', 'sounds/sound005.wav', 'sounds/sound006.wav', 'sounds/sound007.wav', 'sounds/sound008.wav'],
    audioLoader: new THREE.AudioLoader(),
    soundStimulus: null,
    pianoTones: ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"],
    pianoFrequencies: {
        "C4": 261.63,
        "D4": 293.66,
        "E4": 329.63,
        "F4": 349.23,
        "G4": 392.00,
        "A4": 440.00,
        "B4": 493.88,
        "C5": 523.25
    },
    isLevelLocked: false,
    imageSourceUrl: "images/",
    resultImageUrl: "",
    sceneKey: "S",
    locationKey: "A",
    soundKey: "L",
    colorKey: "K",
    soundSourceUrl: "sounds/",
    isPaused: false, // ‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉú Ï∂îÍ∞Ä
    isFullscreen: false, // üñºÔ∏è Ï†ÑÏ≤¥ÌôîÎ©¥ ÏÉÅÌÉú Ï∂îÍ∞Ä
    targetCountGoals: {},
    useCeilingPanels: false,
    useFloorPanels: false,
panelPositionsCustom: panelPositions.map(pos => ({
        x: pos.x,
        y: pos.y,
        z: pos.z,
rotation: pos.rotation || [0, 0, 0]
    }))
};





// Fisher-Yates (Knuth) ÏÖîÌîå ÏïåÍ≥†Î¶¨Ï¶ò
function shuffleArray(array) {
    const shuffled = array.slice(); // ÏõêÎ≥∏ Î∞∞Ïó¥ Î≥µÏÇ¨
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // ÏöîÏÜå ÍµêÌôò
    }
    console.log("shuffleArray() - Shuffled array:", shuffled);
    return shuffled;
}




const wallColor = 0x262626;
const floorColor = 0x393734;
const panelColor = 0x000000;
const imageScale = 1.0;
const randomizeStimulusColor = true;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 2);
camera.lookAt(0, 1.6, -5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
directionalLight.position.set(0, 1, 0);
directionalLight.intensity = 0.8;
scene.add(directionalLight);


function createBrickTexture() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const width = 512;
    const height = 512;
    canvas.width = width;
    canvas.height = height;
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, width, height);
    const brickHeight = 30;
    const brickWidth = 80;
    const mortarSize = 5;
    ctx.fillStyle = '#e0e0e0';
    let offsetX = 0;
    for (let y = 0; y < height; y += brickHeight + mortarSize) {
        offsetX = (Math.floor(y / (brickHeight + mortarSize)) % 2) * (brickWidth / 2);
        for (let x = -brickWidth / 2; x < width + brickWidth / 2; x += brickWidth + mortarSize) {
            ctx.fillRect(x + offsetX, y, brickWidth, brickHeight);
            ctx.fillStyle = '#d8d8d8';
            for (let i = 0; i < 15; i++) {
                const spotX = x + offsetX + Math.random() * brickWidth;
                const spotY = y + Math.random() * brickHeight;
                const spotSize = 1 + Math.random() * 3;
                ctx.beginPath();
                ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.fillStyle = '#e0e0e0';
        }
    }
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    for (let y = 0; y < height; y += brickHeight + mortarSize) {
        ctx.fillRect(0, y - 1, width, 2);
        offsetX = (Math.floor(y / (brickHeight + mortarSize)) % 2) * (brickWidth / 2);
        for (let x = -brickWidth / 2; x < width + brickWidth / 2; x += brickWidth + mortarSize) {
            ctx.fillRect(x + offsetX - 1, y, 2, brickHeight);
        }
    }
    return new THREE.CanvasTexture(canvas);
}

const brickTexture = createBrickTexture();
brickTexture.wrapT = THREE.RepeatWrapping;
brickTexture.repeat.set(2, 1);

const wallMaterial = new THREE.MeshStandardMaterial({
    map: brickTexture,
    roughness: 0.0,
    metalness: 0.0,
    color: wallColor
});

const wallGeometry = new THREE.BoxGeometry(0.1, roomHeight, roomDepth);
const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
leftWall.position.set(-roomWidth / 2, roomHeight / 2, 0);
scene.add(leftWall);

const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
rightWall.position.set(roomWidth / 2, roomHeight / 2, 0);
scene.add(rightWall);

const backWallGeometry = new THREE.BoxGeometry(roomWidth, roomHeight, 0.1);
const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
backWall.position.set(0, roomHeight / 2, -roomDepth / 2);
scene.add(backWall);

function createWoodTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const context = canvas.getContext('2d');
    context.fillStyle = '#8B4513';
    context.fillRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < 40; i++) {
        const x = Math.random() * canvas.width;
        context.strokeStyle = `rgba(139, 69, 19, ${Math.random() * 0.5})`;
        context.lineWidth = 1 + Math.random() * 10;
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x + Math.random() * 50 - 25, canvas.height);
        context.stroke();
    }
    for (let i = 0; i < 30; i++) {
        const y = Math.random() * canvas.height;
        const width = 2 + Math.random() * 10;
        context.fillStyle = `rgba(60, 30, 15, ${Math.random() * 0.3})`;
        context.fillRect(0, y, canvas.width, width);
    }
    for (let i = 0; i < 800; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const radius = 1 + Math.random() * 2;
        context.fillStyle = `rgba(200, 150, 100, ${Math.random() * 0.2})`;
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.fill();
    }
    return new THREE.CanvasTexture(canvas);
}

const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
const woodTexture = createWoodTexture();
woodTexture.wrapS = THREE.RepeatWrapping;
woodTexture.wrapT = THREE.RepeatWrapping;
woodTexture.repeat.set(4, 4);

const floorMaterial = new THREE.MeshStandardMaterial({
    map: woodTexture,
    roughness: 0.8,
    metalness: 0.2,
    color: floorColor
});

const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
const ceiling = new THREE.Mesh(ceilingGeometry, wallMaterial);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.y = roomHeight;
scene.add(ceiling);

const panelWidth = 1.0;
const panelHeight = 1.0;

const panelMaterial = new THREE.MeshStandardMaterial({
    color: panelColor,
    roughness: 0.5,
    metalness: 0.0
});




const panels = []; // Í∏ÄÎ°úÎ≤å Î∞∞Ïó¥ Ïú†ÏßÄ

function createPanels() {
    console.log("createPanels() - Ìå®ÎÑê ÏÉùÏÑ± ÏãúÏûë, Ïù¥Ï†Ñ Ìå®ÎÑê Ïàò:", panels.length); // ÎîîÎ≤ÑÍπÖ: ÏãúÏûë Î°úÍ∑∏
    // Í∏∞Ï°¥ Ìå®ÎÑê Ï†úÍ±∞
    panels.forEach(panel => {
        scene.remove(panel.group);
        console.log("createPanels() - Í∏∞Ï°¥ Ìå®ÎÑê Ï†úÍ±∞Îê®, ÏúÑÏπò:", panel.position); // ÎîîÎ≤ÑÍπÖ: Ï†úÍ±∞ ÌôïÏù∏
    });
    panels.length = 0; // Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî

    panelPositions.forEach((pos, index) => {
        const isCeiling = index >= 8 && index < 10; // Ï≤úÏû• Ìå®ÎÑê (Ïù∏Îç±Ïä§ 8, 9)
        const isFloor = index >= 10; // Î∞îÎã• Ìå®ÎÑê (Ïù∏Îç±Ïä§ 10, 11)
        // Ï≤úÏû•/Î∞îÎã• Ìå®ÎÑê ÏÇ¨Ïö© Ïó¨Î∂ÄÏóê Îî∞Îùº ÌïÑÌÑ∞ÎßÅ
        if ((isCeiling && !gameState.useCeilingPanels) || (isFloor && !gameState.useFloorPanels)) {
            console.log("createPanels() - Ìå®ÎÑê ÏÉùÏÑ± Ïä§ÌÇµ: Ïù∏Îç±Ïä§=", index, "Ï≤úÏû•=", isCeiling, "Î∞îÎã•=", isFloor); // ÎîîÎ≤ÑÍπÖ: Ïä§ÌÇµ Î°úÍ∑∏
            return;
        }

        const panelGroup = new THREE.Group();
        const panel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, panelHeight, panelDepth),
            panelMaterial
        );
        panelGroup.add(panel);

        // ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏúÑÏπò Ï†ÅÏö© (Í∏∞Î≥∏Í∞í fallback)
        const customPos = gameState.panelPositionsCustom[index] || pos;
        panelGroup.position.set(customPos.x, customPos.y, customPos.z);
        panelGroup.rotation.set(pos.rotation[0], pos.rotation[1], pos.rotation[2]);

        scene.add(panelGroup);
        panels.push({
            group: panelGroup,
            position: index,
            panel: panel,
            rotation: pos.rotation,
            stimulusObject: null
        });
        // ÎîîÎ≤ÑÍπÖ: Ìå®ÎÑê ÌöåÏ†ÑÍ∞í Ï†ÅÏö© ÌôïÏù∏
        console.log("createPanels() - Ìå®ÎÑê ÏÉùÏÑ±Îê®: Ïù∏Îç±Ïä§=", index, "ÏúÑÏπò=", customPos, "ÌöåÏ†Ñ=", {
            x: pos.rotation[0] * 180 / Math.PI, // ÎùºÎîîÏïàÏùÑ ÎèÑ(degree)Î°ú Î≥ÄÌôò
            y: pos.rotation[1] * 180 / Math.PI,
            z: pos.rotation[2] * 180 / Math.PI
        });
    });

    console.log("createPanels() - Ìå®ÎÑê ÏÉùÏÑ± ÏôÑÎ£å, Ï¥ù Ìå®ÎÑê Ïàò:", panels.length); // ÎîîÎ≤ÑÍπÖ: ÏôÑÎ£å Î°úÍ∑∏
}

// Ï¥àÍ∏∞ Ìò∏Ï∂ú (Í∏∞Ï°¥ Ï†ïÏ†Å Ï¥àÍ∏∞Ìôî ÎåÄÏ≤¥)
createPanels();







const imageLoader = new THREE.TextureLoader();
const imageTextures = [];
//ÎûúÎç§ ÏÉâÏÉÅ Ï¢ÖÎ•òÌëú
const distinctColors = [
  new THREE.Color(0xFFFF00), // Î∞ùÏùÄ ÎÖ∏Îûë (Bright Yellow) - Í≤ÄÏùÄÏÉâÍ≥º ÎåÄÎπÑÍ∞Ä Îß§Ïö∞ Í∞ïÌïòÏó¨ ÎààÏóê Ïûò ÎùïÎãàÎã§.
  new THREE.Color(0x00FFFF), // ÏãúÏïà (Cyan) - Î∞ùÍ≥† ÏÑ†Î™ÖÌïòÎ©∞ ÎÖ∏ÎûëÍ≥º ÎöúÎ†∑ÌïòÍ≤å Íµ¨Î∂ÑÎê©ÎãàÎã§.
  new THREE.Color(0x00FF00), // Î∞ùÏùÄ Ï¥àÎ°ù (Bright Green) - ÎààÏóê Ìé∏ÏïàÌïòÎ©¥ÏÑúÎèÑ Í≤ÄÏùÄÏÉâ Î∞∞Í≤ΩÏóêÏÑú Ïûò Î≥¥ÏûÖÎãàÎã§.
  new THREE.Color(0xFF0000), // Î∞ùÏùÄ Îπ®Í∞ï (Bright Red) - Ï£ºÎ™©ÏÑ±Ïù¥ ÎÜíÍ≥† Îã§Î•∏ ÏÉâÏÉÅÎì§Í≥º Î™ÖÌôïÌûà ÎåÄÎπÑÎê©ÎãàÎã§.
  new THREE.Color(0x0000FF), // Î∞ùÏùÄ ÌååÎûë (Bright Blue) - ÏÑ†Î™ÖÌïòÎ©∞ Îã§Î•∏ Î∞ùÏùÄ ÏÉâÏÉÅÎì§Í≥º Íµ¨Î≥ÑÎê©ÎãàÎã§.
  new THREE.Color(0xFFA500), // Ï£ºÌô© (Orange) - ÎÖ∏ÎûëÍ≥º Îπ®Í∞ï ÏÇ¨Ïù¥Ïùò ÏÉâÏúºÎ°ú, ÎöúÎ†∑Ìïú Ï°¥Ïû¨Í∞êÏùÑ ÎÇòÌÉÄÎÉÖÎãàÎã§.
  new THREE.Color(0x800080), // Î≥¥Îùº (Purple) - ÌååÎûëÍ≥º Îπ®Í∞ïÏùò Ï°∞Ìï©ÏúºÎ°ú ÎèÖÌäπÌïú ÎäêÎÇåÏùÑ Ï£ºÎ©∞ Íµ¨Î∂ÑÏù¥ ÏâΩÏäµÎãàÎã§.
  new THREE.Color(0xFFFFFF)  // Ìù∞ÏÉâ (White) - Í∞ÄÏû• ÎÜíÏùÄ ÎåÄÎπÑÎ•º Ï†úÍ≥µÌïòÎ©∞ Í∏∞Ï§Ä ÏÉâÏÉÅÏúºÎ°ú Ïú†Ïö©Ìï©ÎãàÎã§.
];

function getRandomColor() {
    return distinctColors[Math.floor(Math.random() * distinctColors.length)];
}

function loadImageTextures() {
    // Í∏∞Ï°¥ Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
    imageTextures.length = 0;

    // ÌïòÏúÑ Ìè¥Îçî Î™©Î°ù Ï†ïÏùò (ÏÇ¨Ïö©ÏûêÍ∞Ä ÏõêÌïòÎäî Ìè¥ÎçîÎ™ÖÏúºÎ°ú Î≥ÄÍ≤Ω Í∞ÄÎä•)
    const subFolders = ['folder2', 'folder3'];
    console.log("loadImageTextures() - ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌïòÏúÑ Ìè¥Îçî Î™©Î°ù:", subFolders);

    // ÎûúÎç§ÏúºÎ°ú ÌïòÏúÑ Ìè¥Îçî ÏÑ†ÌÉù
    const selectedFolder = subFolders[Math.floor(Math.random() * subFolders.length)];
    console.log("loadImageTextures() - ÏÑ†ÌÉùÎêú ÌïòÏúÑ Ìè¥Îçî:", selectedFolder);

    // Í∏∞Î≥∏ URL ÏÑ§Ï†ï
    const baseUrl = `${gameState.imageSourceUrl}${selectedFolder}/`;
    const maxImages = 100; // ÏµúÎåÄ ÏãúÎèÑÌï† Ïù¥ÎØ∏ÏßÄ Í∞úÏàò (ÌïÑÏöî Ïãú Ï°∞Ï†ï Í∞ÄÎä•)
    const promises = [];

    // Ïù¥ÎØ∏ÏßÄ Î°úÎî© ÏãúÎèÑ
    for (let i = 1; i <= maxImages; i++) {
        const filename = `image${String(i).padStart(3, '0')}.png`; // ÌååÏùºÎ™Ö ÌòïÏãù: image001.png
        const loadPromise = new Promise((resolve) => {
            imageLoader.load(
                `${baseUrl}${filename}`,
                (loadedTexture) => {
                    // Ïù¥ÎØ∏ÏßÄ Î°úÎî© ÏÑ±Í≥µ
                    console.log(`loadImageTextures() - ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎê®: ${baseUrl}${filename}`);
                    resolve({ 
                        texture: loadedTexture, 
                        color: randomizeStimulusColor ? getRandomColor() : null 
                    });
                },
                undefined,
                (err) => {
                    // Ïù¥ÎØ∏ÏßÄ Î°úÎî© Ïã§Ìå® (ÌååÏùº ÏóÜÏùå)
                    console.log(`loadImageTextures() - ÌååÏùº ÏóÜÏùå: ${baseUrl}${filename}`);
                    resolve(null); // null Î∞òÌôòÏúºÎ°ú Ïã§Ìå® Ï≤òÎ¶¨
                }
            );
        });
        promises.push(loadPromise);
    }

    // Î™®Îì† Î°úÎî© ÏûëÏóÖ ÏôÑÎ£å ÌõÑ Ï≤òÎ¶¨
    return Promise.all(promises).then(results => {
        results.forEach(result => {
            if (result) {
                imageTextures.push(result); // ÏÑ±Í≥µÌïú Ïù¥ÎØ∏ÏßÄÎßå Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
            }
        });
        console.log(`loadImageTextures() - Ï¥ù ${imageTextures.length}Í∞úÏùò Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎê® from ${selectedFolder}`);
        
        // Î°úÎìúÎêú Ïù¥ÎØ∏ÏßÄÍ∞Ä 0Í∞úÏùº Í≤ΩÏö∞ Í≤ΩÍ≥†
        if (imageTextures.length === 0) {
            console.error("loadImageTextures() - Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïòÎÇòÎèÑ Î°úÎìúÎêòÏßÄ ÏïäÏùå. Ìè¥Îçî Í≤ΩÎ°ú ÎòêÎäî ÌååÏùºÎ™ÖÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.");
        }
    });
}












function createStimulusImage(imageIndex, panel, colorIndex) {
¬† clearStimulus(panel);
¬† const imageGeometry = new THREE.PlaneGeometry(panelWidth * imageScale, panelHeight * imageScale);
¬† const imageMaterial = new THREE.MeshBasicMaterial({
¬† ¬† ¬† map: imageTextures[imageIndex].texture,
¬† ¬† ¬† transparent: true,
¬† ¬† ¬† blending: THREE.NormalBlending
¬† });
¬† if (gameState.stimulusTypes.includes("color")) {
¬† ¬† ¬† const colors = distinctColors;
¬† ¬† ¬† // colorIndexÍ∞Ä Ïú†Ìö®Ìïú Î≤îÏúÑ ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
¬† ¬† ¬† if (colorIndex >= 0 && colorIndex < colors.length) {
¬† ¬† ¬† ¬† ¬† imageMaterial.color = colors[colorIndex];
¬† ¬† ¬† ¬† ¬† gameState.currentColorStimulusColor = colors[colorIndex];
¬† ¬† ¬† } else if (imageTextures[imageIndex].color && randomizeStimulusColor) {
¬† ¬† ¬† ¬† ¬† imageMaterial.color = imageTextures[imageIndex].color;
¬† ¬† ¬† ¬† ¬† gameState.currentColorStimulusColor = imageTextures[imageIndex].color;
¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† gameState.currentColorStimulusColor = null;
¬† ¬† ¬† }
¬† }
¬† const imagePlane = new THREE.Mesh(imageGeometry, imageMaterial);
¬† imagePlane.position.set(0, 0, panelDepth / 2 + 0.01);
¬† panel.group.add(imagePlane);
¬† panel.stimulusObject = imagePlane;
¬† return imagePlane;
}

function clearStimulus(panel) {
    if (panel.stimulusObject) {
        panel.group.remove(panel.stimulusObject);
        panel.stimulusObject = null;
    }
}

function clearAllStimuli() {
    panels.forEach(panel => {
        clearStimulus(panel);
    });
}

const sceneIndicator = document.getElementById('scene-indicator');
const locationIndicator = document.getElementById('location-indicator');
const soundIndicator = document.getElementById('sound-indicator');
const colorIndicator = document.getElementById('color-indicator');



function resetIndicators() {
    console.log("resetIndicators() - Resetting all indicators, previous states:", {
        scene: sceneIndicator.classList.value,
        location: locationIndicator.classList.value,
        sound: soundIndicator.classList.value,
        color: colorIndicator.classList.value
    });
    sceneIndicator.classList.remove('correct', 'incorrect', 'missed', 'early');
    locationIndicator.classList.remove('correct', 'incorrect', 'missed', 'early');
    soundIndicator.classList.remove('correct', 'incorrect', 'missed', 'early');
    colorIndicator.classList.remove('correct', 'incorrect', 'missed', 'early');
    gameState.sceneTargetProcessed = false;
    gameState.locationTargetProcessed = false;
    gameState.soundTargetProcessed = false;
    gameState.colorTargetProcessed = false;
    gameState.canRespondScene = true;      // Scene ÏùëÎãµ Í∞ÄÎä•ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
    gameState.canRespondLocation = true;   // Location ÏùëÎãµ Í∞ÄÎä•ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
    gameState.canRespondSound = true;      // Sound ÏùëÎãµ Í∞ÄÎä•ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
    gameState.canRespondColor = true;      // Color ÏùëÎãµ Í∞ÄÎä•ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
    console.log("resetIndicators() - Reset complete, canRespond states:", {
        scene: gameState.canRespondScene,
        location: gameState.canRespondLocation,
        sound: gameState.canRespondSound,
        color: gameState.canRespondColor
    });
}



function showIndicatorFeedback(indicatorId, isCorrect) {
    console.log(`showIndicatorFeedback() - Ï†ÅÏö©: ${indicatorId}, Ï†ïÎãµ Ïó¨Î∂Ä: ${isCorrect}`);
    const indicator = document.getElementById(indicatorId);
    if (!indicator) {
        console.error(`showIndicatorFeedback() - Indicator with ID '${indicatorId}' not found in DOM.`);
        return;
    }

    // Í∏∞ÎåÄÍ∞íÍ≥º Ïã§Ï†úÍ∞í ÎπÑÍµê
    const expectedCorrect = gameState[`currentIs${indicatorId.split('-')[0].charAt(0).toUpperCase() + indicatorId.split('-')[0].slice(1)}Target`];
    console.log(`showIndicatorFeedback() - ÌîºÎìúÎ∞± Í≤ÄÏ¶ù: Í∏∞ÎåÄÍ∞í=${expectedCorrect && isCorrect}, Ïã§Ï†úÍ∞í=${isCorrect}`);
    if ((expectedCorrect && isCorrect) !== isCorrect) {
        console.log("%c[Í≤ΩÍ≥†] ÌîºÎìúÎ∞± Î∂àÏùºÏπò: ÏÇ¨Ïö©ÏûêÍ∞Ä Í∏∞ÎåÄÌïú Í≤∞Í≥ºÏôÄ Îã§Î•º Ïàò ÏûàÏùå", "color: orange");
    }

    console.log(`showIndicatorFeedback() - Indicator found: ${indicatorId}, applying classes`);
    indicator.classList.remove('correct', 'incorrect');
    indicator.classList.add(isCorrect ? 'correct' : 'incorrect');
}



function showEarlyResponseFeedback(indicatorId) {
    console.log(`showEarlyResponseFeedback() - Ï†ÅÏö©: ${indicatorId}`);
    const indicator = document.getElementById(indicatorId);
    if (!indicator) {
        console.error(`showEarlyResponseFeedback() - Indicator with ID '${indicatorId}' not found in DOM.`);
        return;
    }
    console.log(`showEarlyResponseFeedback() - Indicator found: ${indicatorId}, marking as early`);
    indicator.classList.add('early');
}


function showMissedTargetFeedback(indicatorId) {
    const indicator = typeof indicatorId === 'string' ? document.getElementById(indicatorId) : indicatorId;
    if (!indicator) {
        console.error(`showMissedTargetFeedback() - Indicator with ID '${indicatorId}' not found in DOM.`);
        return;
    }
    indicator.classList.add('missed');
}










function playSound(soundIndex) {
    stopSound(); // Í∏∞Ï°¥ ÏÜåÎ¶¨ Ï§ëÏßÄ
    if (!gameState.stimulusTypes.includes("sound")) {
        console.log("playSound() - Sound stimulus not enabled, skipping.");
        return;
    }
    if (gameState.soundSource === "pianoTones") {
        if (soundIndex >= 0 && soundIndex < gameState.pianoTones.length) {
            const note = gameState.pianoTones[soundIndex];
            const frequency = gameState.pianoFrequencies[note];
            if (frequency) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0.3;
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                oscillator.start();
                gameState.soundStimulus = { oscillator: oscillator, gainNode: gainNode };
                setTimeout(() => {
                    stopSound();
                }, 1000);
                console.log("playSound() - Piano tone:", note, frequency, "Hz, duration: 1000ms");
            } else {
                console.error("playSound() - Invalid piano note:", note);
            }
        } else {
            console.error("playSound() - Invalid pianoTones index:", soundIndex, "Max:", gameState.pianoTones.length - 1);
        }
    } else if (gameState.soundSource === "soundFiles") {
        if (soundIndex >= 0 && soundIndex < gameState.soundFiles.length) {
            const baseUrl = gameState.soundSourceUrl || "sounds/";
            const soundUrl = `${baseUrl}${gameState.soundFiles[soundIndex].split('/').pop()}`;
            console.log("playSound() - Loading sound file:", soundUrl);
            gameState.audioLoader.load(
                soundUrl,
                function (buffer) {
                    const listener = new THREE.AudioListener();
                    camera.add(listener);
                    const sound = new THREE.Audio(listener);
                    sound.setBuffer(buffer);
                    sound.setVolume(0.5);
                    sound.play();
                    gameState.soundStimulus = sound;
                    console.log("playSound() - Sound file playing:", soundUrl);
                },
                function (xhr) {
                    console.log("playSound() - Loading progress:", (xhr.loaded / xhr.total * 100) + '%');
                },
                function (err) {
                    console.error("playSound() - Error loading sound:", soundUrl, err);
                }
            );
        } else {
            console.error("playSound() - Invalid soundFiles index:", soundIndex, "Max:", gameState.soundFiles.length - 1);
        }
    }
}

function stopSound() {
    if (gameState.soundSource === "pianoTones") {
        if (gameState.soundStimulus && gameState.soundStimulus.oscillator && gameState.soundStimulus.gainNode) {
            const gainNode = gameState.soundStimulus.gainNode;
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
            setTimeout(() => {
                if (gameState.soundStimulus && gameState.soundStimulus.oscillator) {
                    gameState.soundStimulus.oscillator.stop();
                    gameState.soundStimulus.oscillator.disconnect();
                    gameState.soundStimulus.gainNode.disconnect();
                    gameState.soundStimulus = null;
                    console.log("stopSound() - Piano tone stopped with fade-out (200ms)");
                }
            }, 200);
        } else {
            console.log("stopSound() - No piano tone to stop.");
        }
    } else {
        if (gameState.soundStimulus && gameState.soundStimulus.isPlaying) {
            gameState.soundStimulus.stop();
            gameState.soundStimulus = null;
            console.log("stopSound() - Sound file stopped");
        } else {
            console.log("stopSound() - No sound file playing to stop.");
        }
    }
}

function clearAllSounds() {
    stopSound();
    console.log("clearAllSounds() - All sounds cleared.");
}


function showStimulus(imageIndex, panelIndex, soundIndex, colorIndex) {
    if (gameState.isPaused) return;
    console.log("showStimulus() - ÏãúÏûë: imageIndex:", imageIndex, "panelIndex:", panelIndex, "soundIndex:", soundIndex, "colorIndex:", colorIndex, "currentStimulus:", gameState.currentStimulus);
    resetIndicators();
    const panel = panels[panelIndex];

    if (gameState.currentStimulus >= gameState.nBackLevel) {
        gameState.currentIsSceneTarget = gameState.stimulusSequence[gameState.currentStimulus].isSceneTarget;
        gameState.currentIsLocationTarget = gameState.stimulusSequence[gameState.currentStimulus].isLocationTarget;
        gameState.currentIsSoundTarget = gameState.stimulusSequence[gameState.currentStimulus].isSoundTarget;
        gameState.currentIsColorTarget = gameState.stimulusSequence[gameState.currentStimulus].isColorTarget;
        console.log("showStimulus() - ÏãúÌÄÄÏä§ÏóêÏÑú Ï†ïÏùòÎêú ÌÉÄÍ≤ü:", {
            scene: gameState.currentIsSceneTarget,
            location: gameState.currentIsLocationTarget,
            sound: gameState.currentIsSoundTarget,
            color: gameState.currentIsColorTarget
        });
    } else {
        gameState.currentIsSceneTarget = false;
        gameState.currentIsLocationTarget = false;
        gameState.currentIsSoundTarget = false;
        gameState.currentIsColorTarget = false;
        console.log("showStimulus() - Ï¥àÍ∏∞ ÏûêÍ∑π, ÌÉÄÍ≤ü ÏóÜÏùå");
    }

    createStimulusImage(imageIndex, panel, colorIndex);
    if (gameState.stimulusTypes.includes("sound")) {
        playSound(soundIndex);
    }

    console.log("showStimulus() - Presented stimulus:", imageIndex, panelIndex, soundIndex, colorIndex);
    gameState.sceneHistory.push(imageIndex);
    gameState.locationHistory.push(panelIndex);
    gameState.soundHistory.push(soundIndex);
    gameState.colorHistory.push(colorIndex);

    gameState.presentedStimulusHistory.push({
        imageIndex,
        panelIndex,
        soundIndex,
        colorIndex
    });

    gameState.currentStimulus++;

    // ÏûêÍ∑π Í∞Ñ Í∞ÑÍ≤© ÏãúÍ∞Ñ Í≥ÑÏÇ∞
    let currentInterval;
    if (gameState.randomizeInterval) {
        const min = gameState.minInterval;
        const max = gameState.maxInterval;
        if (gameState.previousInterval === null) {
            // Ï≤´ Î≤àÏß∏ ÏûêÍ∑π: ÏôÑÏ†Ñ Î¨¥ÏûëÏúÑ ÏÑ†ÌÉù
            currentInterval = Math.floor(Math.random() * (max - min + 1)) + min;
            console.log("showStimulus() - Ï≤´ ÏûêÍ∑π Í∞ÑÍ≤© Î¨¥ÏûëÏúÑ ÏÑ†ÌÉù:", currentInterval, "ms");
        } else {
            // Ïù¥Ï†Ñ Í∞ÑÍ≤©ÏùÑ Í≥†Î†§Ìïú Ìé∏Ìñ• Í≥ÑÏÇ∞ (0: min, 1: max)
            const bias = (gameState.previousInterval - min) / (max - min);
            const newBias = 1 - bias; // Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú ÏπòÏö∞Ïπ®
            // 70% Ìé∏Ìñ•, 30% Î¨¥ÏûëÏúÑÏÑ±
            currentInterval = min + (newBias * 0.7 + Math.random() * 0.3) * (max - min);
            currentInterval = Math.floor(Math.min(Math.max(currentInterval, min), max));
            console.log("showStimulus() - Ïù¥Ï†Ñ Í∞ÑÍ≤© Í∏∞Î∞ò ÏÉà Í∞ÑÍ≤© Í≥ÑÏÇ∞:", {
                previous: gameState.previousInterval,
                bias: bias.toFixed(2),
                newBias: newBias.toFixed(2),
                result: currentInterval,
                min: min,
                max: max
            });
        }
        gameState.previousInterval = currentInterval;
    } else {
        currentInterval = gameState.stimulusInterval;
        console.log("showStimulus() - Í≥†Ï†ï Í∞ÑÍ≤© ÏÇ¨Ïö©:", currentInterval, "ms");
    }

    if (gameState.currentStimulus < gameState.stimuliPerBlock) {
        gameState.currentTimer = setTimeout(() => {
            console.log("Timer - Clearing stimuli and stopping sound, currentStimulus:", gameState.currentStimulus, "timestamp:", Date.now());
            clearAllStimuli();
            stopSound();
            gameState.inResponseWindow = true;
            gameState.canRespondScene = true;
            gameState.canRespondLocation = true;
            gameState.canRespondSound = true;
            gameState.canRespondColor = true;

            gameState.responseWindowTimer = setTimeout(() => {
                console.log("Timer - Response window closed, currentStimulus:", gameState.currentStimulus, "currentInterval:", currentInterval, "timestamp:", Date.now());
                gameState.inResponseWindow = false;
                gameState.canRespondScene = false;
                gameState.canRespondLocation = false;
                gameState.canRespondSound = false;
                gameState.canRespondColor = false;

                const lastPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1];
                if (gameState.stimulusTypes.includes("scene") && gameState.currentIsSceneTarget && !gameState.sceneTargetProcessed) {
                    showMissedTargetFeedback('scene-indicator');
                    gameState.sceneErrors++;
                    console.log("Timer - Missed scene target:", {
                        imageIndex: lastPresented.imageIndex,
                        nBackIndex: gameState.sceneHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        sceneErrors: gameState.sceneErrors
                    });
                }
                if (gameState.stimulusTypes.includes("location") && gameState.currentIsLocationTarget && !gameState.locationTargetProcessed) {
                    showMissedTargetFeedback('location-indicator');
                    gameState.locationErrors++;
                    console.log("Timer - Missed location target:", {
                        panelIndex: lastPresented.panelIndex,
                        nBackIndex: gameState.locationHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        locationErrors: gameState.locationErrors
                    });
                }
                if (gameState.stimulusTypes.includes("sound") && gameState.currentIsSoundTarget && !gameState.soundTargetProcessed) {
                    showMissedTargetFeedback('sound-indicator');
                    gameState.soundErrors++;
                    console.log("Timer - Missed sound target:", {
                        soundIndex: lastPresented.soundIndex,
                        nBackIndex: gameState.soundHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        soundErrors: gameState.soundErrors
                    });
                }
                if (gameState.stimulusTypes.includes("color") && gameState.currentIsColorTarget && !gameState.colorTargetProcessed) {
                    showMissedTargetFeedback('color-indicator');
                    gameState.colorErrors++;
                    console.log("Timer - Missed color target:", {
                        colorIndex: lastPresented.colorIndex,
                        nBackIndex: gameState.colorHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        colorErrors: gameState.colorErrors
                    });
                }

                console.log("Timer - Error counts after response window:", {
                    sceneErrors: gameState.sceneErrors,
                    locationErrors: gameState.locationErrors,
                    soundErrors: gameState.soundErrors,
                    colorErrors: gameState.colorErrors
                });

                generateNextStimulus();
            }, currentInterval);
        }, gameState.stimulusDuration);
    } else {
        gameState.currentTimer = setTimeout(() => {
            console.log("Timer - Final stimulus cleared, ending block, timestamp:", Date.now());
            clearAllStimuli();
            stopSound();
            gameState.inResponseWindow = true;
            gameState.canRespondScene = true;
            gameState.canRespondLocation = true;
            gameState.canRespondSound = true;
            gameState.canRespondColor = true;

            gameState.responseWindowTimer = setTimeout(() => {
                console.log("Timer - Response window closed (final), currentStimulus:", gameState.currentStimulus, "currentInterval:", currentInterval, "timestamp:", Date.now());
                gameState.inResponseWindow = false;
                gameState.canRespondScene = false;
                gameState.canRespondLocation = false;
                gameState.canRespondSound = false;
                gameState.canRespondColor = false;

                const lastPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1];
                if (gameState.stimulusTypes.includes("scene") && gameState.currentIsSceneTarget && !gameState.sceneTargetProcessed) {
                    showMissedTargetFeedback('scene-indicator');
                    gameState.sceneErrors++;
                    console.log("Timer - Missed scene target (final):", {
                        imageIndex: lastPresented.imageIndex,
                        nBackIndex: gameState.sceneHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        sceneErrors: gameState.sceneErrors
                    });
                }
                if (gameState.stimulusTypes.includes("location") && gameState.currentIsLocationTarget && !gameState.locationTargetProcessed) {
                    showMissedTargetFeedback('location-indicator');
                    gameState.locationErrors++;
                    console.log("Timer - Missed location target (final):", {
                        panelIndex: lastPresented.panelIndex,
                        nBackIndex: gameState.locationHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        locationErrors: gameState.locationErrors
                    });
                }
                if (gameState.stimulusTypes.includes("sound") && gameState.currentIsSoundTarget && !gameState.soundTargetProcessed) {
                    showMissedTargetFeedback('sound-indicator');
                    gameState.soundErrors++;
                    console.log("Timer - Missed sound target (final):", {
                        soundIndex: lastPresented.soundIndex,
                        nBackIndex: gameState.soundHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        soundErrors: gameState.soundErrors
                    });
                }
                if (gameState.stimulusTypes.includes("color") && gameState.currentIsColorTarget && !gameState.colorTargetProcessed) {
                    showMissedTargetFeedback('color-indicator');
                    gameState.colorErrors++;
                    console.log("Timer - Missed color target (final):", {
                        colorIndex: lastPresented.colorIndex,
                        nBackIndex: gameState.colorHistory[gameState.currentStimulus - 1 - gameState.nBackLevel],
                        colorErrors: gameState.colorErrors
                    });
                }

                console.log("Timer - Final error counts before ending block:", {
                    sceneErrors: gameState.sceneErrors,
                    locationErrors: gameState.locationErrors,
                    soundErrors: gameState.soundErrors,
                    colorErrors: gameState.colorErrors
                });

                setTimeout(() => {
                    endBlock();
                }, 500);
            }, currentInterval);
        }, gameState.stimulusDuration);
    }
}





function selectIndexAvoidingRecent(recentIndices, maxRange, recentLimit, maxOccurrences = 5) {
    // ÏµúÍ∑º Ïù∏Îç±Ïä§Í∞Ä recentLimitÏùÑ Ï¥àÍ≥ºÌïòÎ©¥ Ïò§ÎûòÎêú Ìï≠Î™© Ï†úÍ±∞
    while (recentIndices.length >= recentLimit) {
        recentIndices.shift();
    }

    // ÌòÑÏû¨ ÏãúÌÄÄÏä§ÏóêÏÑú Í∞Å Í∞íÏùò Îì±Ïû• ÌöüÏàò Ï∂îÏ†Å
    const currentCounts = {};
    recentIndices.forEach(idx => {
        currentCounts[idx] = (currentCounts[idx] || 0) + 1;
    });

    // ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§ Î∞∞Ïó¥ ÏÉùÏÑ±
    const availableIndices = [];
    for (let i = 0; i < maxRange; i++) {
        if (!recentIndices.includes(i) && (currentCounts[i] || 0) < maxOccurrences) {
            availableIndices.push(i);
        }
    }

    // ÎîîÎ≤ÑÍπÖ: ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§ÏôÄ ÌòÑÏû¨ ÏÉÅÌÉú ÌôïÏù∏
    console.log(`selectIndexAvoidingRecent() - ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§: ${availableIndices}, ÏµúÍ∑º ÏÇ¨Ïö©Îêú Ïù∏Îç±Ïä§: ${recentIndices}, ÏµúÎåÄ Î≤îÏúÑ: ${maxRange}, Ï†úÌïú: ${recentLimit}, ÏµúÎåÄ Îì±Ïû• ÌöüÏàò: ${maxOccurrences}`);

    // ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§Í∞Ä ÏóÜÏúºÎ©¥ Î¨¥ÏûëÏúÑ Í∞í Î∞òÌôò
    if (availableIndices.length === 0) {
        console.warn(`selectIndexAvoidingRecent() - ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§Í∞Ä ÏóÜÏùå, 0Î∂ÄÌÑ∞ ${maxRange - 1} Ï§ë Î¨¥ÏûëÏúÑ ÏÑ†ÌÉù`);
        return Math.floor(Math.random() * maxRange);
    }

    // Î¨¥ÏûëÏúÑÎ°ú Ïù∏Îç±Ïä§ ÏÑ†ÌÉù
    const selectedIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
    console.log(`selectIndexAvoidingRecent() - ÏÑ†ÌÉùÎêú Ïù∏Îç±Ïä§: ${selectedIndex}`);

    return selectedIndex;
}
function updateRecentIndices(type, index, n) {
    const historyKey = `${type}History`;
    const recentKey = `recent${type.charAt(0).toUpperCase() + type.slice(1)}Indices`;
    const maxRecent = n + 1;

    gameState[historyKey].push(index);
    gameState[recentKey].push(index);

    if (gameState[recentKey].length > maxRecent) {
        const removedIndex = gameState[recentKey].shift();
        console.log(`updateRecentIndices() - ${type} ÏóÖÎç∞Ïù¥Ìä∏: Ï†úÍ±∞Îêú Ïù∏Îç±Ïä§ ${removedIndex}, Ï∂îÍ∞ÄÎêú Ïù∏Îç±Ïä§ ${index}`);
    } else {
        console.log(`updateRecentIndices() - ${type} ÏóÖÎç∞Ïù¥Ìä∏: Ï∂îÍ∞ÄÎêú Ïù∏Îç±Ïä§ ${index}`);
    }
}

function generateNextStimulus() {
    if (!gameState.isPlaying || gameState.isPaused) return;
    console.log("generateNextStimulus() - Starting, currentStimulus:", gameState.currentStimulus);

    if (!gameState.stimulusSequence || gameState.currentStimulus >= gameState.stimulusSequence.length) {
        console.error("generateNextStimulus() - Stimulus sequence is invalid or index out of bounds", {
            stimulusSequence: gameState.stimulusSequence,
            currentStimulus: gameState.currentStimulus
        });
        endBlock();
        return;
    }

    const stimulus = gameState.stimulusSequence[gameState.currentStimulus];
    if (!stimulus || typeof stimulus !== 'object') {
        console.error("generateNextStimulus() - Invalid stimulus object at index:", gameState.currentStimulus, "stimulus:", stimulus);
        endBlock();
        return;
    }

    // ÏÜçÏÑ± ÌôïÏù∏ Î∞è Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
    const { 
        imageIndex = 0, 
        panelIndex = 0, 
        soundIndex = 0, 
        colorIndex = 0, 
        targetType = "non-target" 
    } = stimulus;

    console.log("generateNextStimulus() - Stimulus data:", { imageIndex, panelIndex, soundIndex, colorIndex, targetType });

    updateStimulusCounter();
    showStimulus(imageIndex, panelIndex, soundIndex, colorIndex);
}




function cancelAllTimers() {
    if (gameState.currentTimer) {
        clearTimeout(gameState.currentTimer);
        gameState.currentTimer = null;
        console.log("cancelAllTimers() - Cleared currentTimer");
    }
    if (gameState.responseWindowTimer) {
        clearTimeout(gameState.responseWindowTimer);
        gameState.responseWindowTimer = null;
        console.log("cancelAllTimers() - Cleared responseWindowTimer");
    }
    console.log("cancelAllTimers() - All timers canceled", { timestamp: Date.now() });
}

function pauseGame() {
    if (!gameState.isPlaying || gameState.isPaused) {
        console.log("pauseGame() - Aborted: Game not playing or already paused", {
            isPlaying: gameState.isPlaying,
            isPaused: gameState.isPaused
        });
        return;
    }
    gameState.isPaused = true;
    cancelAllTimers();
    clearAllStimuli();
    stopSound();
    const pauseScreen = document.getElementById('pauseScreen');
    if (pauseScreen) {
        pauseScreen.style.display = 'flex';
        console.log("pauseGame() - pauseScreen displayed successfully");
    } else {
        console.error("pauseGame() - pauseScreen element not found in DOM");
    }
    gameState.isPlaying = false; // Prevent generateNextStimulus()
    console.log("pauseGame() - Game paused, timers canceled, stimuli cleared", {
        timestamp: Date.now()
    });
}

// ‚è∏Ô∏è Í≤åÏûÑ Ïû¨Í∞ú Í∏∞Îä•
function resumeGame() {
    if (!gameState.isPaused) return;
    gameState.isPaused = false;
    document.getElementById('pauseScreen').style.display = 'none';
    gameState.isPlaying = true; // generateNextStimulus() Îã§Ïãú ÏãúÏûë Í∞ÄÎä•ÌïòÎèÑÎ°ù
    generateNextStimulus(); // Ï¶âÏãú Îã§Ïùå stimuli ÌëúÏãú
}

// üñºÔ∏è Ï†ÑÏ≤¥ÌôîÎ©¥ ÌÜ†Í∏Ä Ìï®Ïàò
function toggleFullscreen() {
    const guide = document.getElementById('fullscreenGuide'); // Î©îÏãúÏßÄ ÏöîÏÜå
    if (!gameState.isFullscreen) {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) {
            document.documentElement.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen();
        }
        // iPhoneÏóêÏÑúÎßå Î©îÏãúÏßÄ ÌëúÏãú
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            guide.style.display = 'block';
            console.log('Ï†ÑÏ≤¥ÌôîÎ©¥ ÏïàÎÇ¥ Î©îÏãúÏßÄ ÌëúÏãúÎê®! üì±');
            setTimeout(() => {
                guide.style.display = 'none';
                console.log('Ï†ÑÏ≤¥ÌôîÎ©¥ ÏïàÎÇ¥ Î©îÏãúÏßÄ 3Ï¥à ÌõÑ Ïà®ÍπÄ! ‚è≥');
            }, 3000);
        }
        gameState.isFullscreen = true;
        document.getElementById('fullscreenBtn').textContent = 'Normal';
        console.log('Ï†ÑÏ≤¥ÌôîÎ©¥ Î™®Îìú ÌôúÏÑ±Ìôî! üåï');
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        guide.style.display = 'none'; // Î™®Îìú Ìï¥Ï†ú Ïãú Î©îÏãúÏßÄ Ï¶âÏãú Ïà®ÍπÄ
        console.log('Ï†ÑÏ≤¥ÌôîÎ©¥ ÏïàÎÇ¥ Î©îÏãúÏßÄ Ïà®ÍπÄ (Î™®Îìú Ìï¥Ï†ú)! üö™');
        gameState.isFullscreen = false;
        document.getElementById('fullscreenBtn').textContent = 'Full';
        console.log('ÏùºÎ∞ò ÌôîÎ©¥ Î™®ÎìúÎ°ú Î≥µÍ∑Ä! ‚òÄÔ∏è');
    }
}



 function handleKeyPress(e) {
    if (gameState.isPaused) return;
    if (e.key === 'Escape') {
        showTitleScreen();
        return;
    }
    if (!gameState.isPlaying) {
        if (e.code === 'Space') {
            const resultScreen = document.getElementById('resultScreen');
            if (resultScreen) {
                resultScreen.style.display = 'none';
            }
            startBlock();
        }
        return;
    }
    console.log("handleKeyPress() - ÌÇ§ ÏûÖÎ†•Îê®:", e.key, "ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now(), "ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä:", gameState.canRespond, "ÏùëÎãµ Ï∞Ω Ïó¨Î∂Ä:", gameState.inResponseWindow);

    // ÌòÑÏû¨ ÏûêÍ∑πÏùò ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂ÑÏÑù
    const currentSequence = gameState.stimulusSequence[gameState.currentStimulus - 1] || {};
    console.log(`[Î∂ÑÏÑù] ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú: scene=${currentSequence.isSceneTarget}, location=${currentSequence.isLocationTarget}, sound=${currentSequence.isSoundTarget}, color=${currentSequence.isColorTarget}`);

    // Scene ÏùëÎãµ Ï≤òÎ¶¨
    if (gameState.stimulusTypes.includes("scene") && e.key.toUpperCase() === gameState.sceneKey && !gameState.sceneTargetProcessed && gameState.canRespond) {
        if (!currentSequence.isSceneTarget) {
            console.log("%c[Î∂ÑÏÑù] Í≤ΩÍ≥†: 'S' ÌÇ§ ÏûÖÎ†•ÏùÄ Scene ÌÉÄÍ≤üÏù¥ ÏïÑÎãò. ÌòÑÏû¨ ÌÉÄÍ≤üÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.", "color: yellow");
        }
        console.log("handleKeyPress() - Scene ÌÇ§ ÏûÖÎ†•Îê®:", e.key, "handleSceneResponse() Ìò∏Ï∂ú");
        handleSceneResponse();
    }
    // Location ÏùëÎãµ Ï≤òÎ¶¨
    if (gameState.stimulusTypes.includes("location") && e.key.toUpperCase() === gameState.locationKey && !gameState.locationTargetProcessed && gameState.canRespond) {
        if (!currentSequence.isLocationTarget) {
            console.log("%c[Î∂ÑÏÑù] Í≤ΩÍ≥†: 'A' ÌÇ§ ÏûÖÎ†•ÏùÄ Location ÌÉÄÍ≤üÏù¥ ÏïÑÎãò. ÌòÑÏû¨ ÌÉÄÍ≤üÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.", "color: yellow");
        }
        console.log("handleKeyPress() - Location ÌÇ§ ÏûÖÎ†•Îê®:", e.key, "handleLocationResponse() Ìò∏Ï∂ú");
        handleLocationResponse();
    }
    // Sound ÏùëÎãµ Ï≤òÎ¶¨
    if (gameState.stimulusTypes.includes("sound") && e.key.toUpperCase() === gameState.soundKey && !gameState.soundTargetProcessed && gameState.canRespond) {
        if (!currentSequence.isSoundTarget) {
            console.log("%c[Î∂ÑÏÑù] Í≤ΩÍ≥†: 'L' ÌÇ§ ÏûÖÎ†•ÏùÄ Sound ÌÉÄÍ≤üÏù¥ ÏïÑÎãò. ÌòÑÏû¨ ÌÉÄÍ≤üÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.", "color: yellow");
        }
        console.log("handleKeyPress() - Sound ÌÇ§ ÏûÖÎ†•Îê®:", e.key, "handleSoundResponse() Ìò∏Ï∂ú");
        handleSoundResponse();
    }
    // Color ÏùëÎãµ Ï≤òÎ¶¨
    if (gameState.stimulusTypes.includes("color") && e.key.toUpperCase() === gameState.colorKey && !gameState.colorTargetProcessed && gameState.canRespond) {
        if (!currentSequence.isColorTarget) {
            console.log("%c[Î∂ÑÏÑù] Í≤ΩÍ≥†: 'K' ÌÇ§ ÏûÖÎ†•ÏùÄ Color ÌÉÄÍ≤üÏù¥ ÏïÑÎãò. ÌòÑÏû¨ ÌÉÄÍ≤üÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.", "color: yellow");
        }
        console.log("handleKeyPress() - Color ÌÇ§ ÏûÖÎ†•Îê®:", e.key, "handleColorResponse() Ìò∏Ï∂ú");
        handleColorResponse();
    }
}




function handleSceneResponse() {
    if (gameState.isPaused) return;
    console.log("handleSceneResponse() - Ï≤òÎ¶¨ ÏãúÏûë: canRespondScene=", gameState.canRespondScene, "sceneTargetProcessed=", gameState.sceneTargetProcessed, "currentStimulus=", gameState.currentStimulus);

    console.log("handleSceneResponse() - ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú:", {
        currentIsSceneTarget: gameState.currentIsSceneTarget,
        inResponseWindow: gameState.inResponseWindow
    });

    if (!gameState.canRespondScene || gameState.sceneTargetProcessed) {
        console.log("handleSceneResponse() - ÏùëÎãµ Ï∞®Îã®: canRespondScene=", gameState.canRespondScene, "sceneTargetProcessed=", gameState.sceneTargetProcessed);
        return;
    }

    gameState.sceneTargetProcessed = true;
    gameState.canRespondScene = false;
    if (gameState.currentStimulus <= gameState.nBackLevel) {
        showEarlyResponseFeedback('scene-indicator');
        console.log("handleSceneResponse() - Ï°∞Í∏∞ ÏùëÎãµ: stimulus=", gameState.currentStimulus, "nBackLevel=", gameState.nBackLevel);
        return;
    }

    gameState.sceneResponses++;
    const currentPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1];
    const nBackPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1 - gameState.nBackLevel];
    const sequenceTarget = gameState.stimulusSequence[gameState.currentStimulus - 1];

    console.log("handleSceneResponse() - Ïû•Î©¥ ÎπÑÍµê: ÌòÑÏû¨ imageIndex=", currentPresented.imageIndex, "NÎ∞± imageIndex=", nBackPresented.imageIndex);

    const isDynamicMatch = currentPresented.imageIndex === nBackPresented.imageIndex;
    const isCorrect = gameState.currentIsSceneTarget && isDynamicMatch;
    console.log("handleSceneResponse() - ÌÉÄÍ≤ü Í≤ÄÏ¶ù:", {
        predefined: gameState.currentIsSceneTarget,
        dynamic: isDynamicMatch,
        match: isCorrect,
        sequenceIsTarget: sequenceTarget.isSceneTarget
    });

    // Î∂ÑÏÑù Î°úÏßÅ: ÏÇ¨Ïö©ÏûêÍ∞Ä Ïù¥Ìï¥ÌïòÍ∏∞ ÏâΩÍ≤å Ïò§Îãµ Ïù¥Ïú† Î™ÖÌôïÌôî
    console.log(`[Î∂ÑÏÑù] ÌÉÄÍ≤ü Ïó¨Î∂Ä: ÏãúÌÄÄÏä§ ÌÉÄÍ≤ü=${sequenceTarget.isSceneTarget}, ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú=${gameState.currentIsSceneTarget}, ÎèôÏ†Å ÎπÑÍµê=${isDynamicMatch}`);
    if (gameState.currentIsSceneTarget && !isDynamicMatch) {
        console.log("%c[Î∂ÑÏÑù] ÌÉÄÍ≤ü Ïû•Î©¥ ÏûêÍ∑πÏóê Î∞òÏùëÌñàÏúºÎÇò NÎ∞± ÎπÑÍµê Ïã§Ìå®Î°ú Ïò§Îãµ Ï≤òÎ¶¨Îê®", "color: red");
    } else if (!gameState.currentIsSceneTarget && isDynamicMatch) {
        console.log("%c[Î∂ÑÏÑù] ÎÖºÌÉÄÍ≤ü Ïû•Î©¥ ÏûêÍ∑πÏóê Ïò§Î∞òÏùë - ÎãàÏñºÎØ∏Ïä§ Î∞úÏÉù", "color: orange");
    } else if (!gameState.currentIsSceneTarget && !isDynamicMatch) {
        console.log("[Î∂ÑÏÑù] ÎÖºÌÉÄÍ≤ü Ïû•Î©¥ ÏûêÍ∑πÏóê Ïò§Î∞òÏùë");
    } else {
        console.log("[Î∂ÑÏÑù] ÌÉÄÍ≤ü Ïû•Î©¥ ÏûêÍ∑πÏóê Ï†ïÌôïÌûà Î∞òÏùëÌï®");
    }

    showIndicatorFeedback('scene-indicator', isCorrect);

    if (gameState.currentIsSceneTarget) {
        if (isCorrect) {
            console.log("handleSceneResponse() - Ïû•Î©¥ Ï†ïÎãµ: isCorrect=", isCorrect);
        } else {
            gameState.sceneErrors++;
            gameState.targetMissedErrors.scene++;
            console.log("handleSceneResponse() - Ïû•Î©¥ Ïò§Î•ò (ÌÉÄÍ≤ü ÎÜìÏπ®): sceneErrors=", gameState.sceneErrors);
        }
    } else {
        if (isDynamicMatch) {
            gameState.sceneErrors++;
            gameState.nonTargetFalseResponses.scene++;
            gameState.nearMissResponses++;
            nearMissHistory.push({
                type: 'scene',
                timestamp: Date.now(),
                current: currentPresented.imageIndex,
                nBack: nBackPresented.imageIndex
            });
            console.log("handleSceneResponse() - Ïû•Î©¥ Ïò§Î•ò (ÎãàÏñºÎØ∏Ïä§): sceneErrors=", gameState.sceneErrors, "nearMissResponses=", gameState.nearMissResponses);
        } else {
            gameState.sceneErrors++;
            gameState.nonTargetFalseResponses.scene++;
            console.log("handleSceneResponse() - Ïû•Î©¥ Ïò§Î•ò (ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë): sceneErrors=", gameState.sceneErrors);
        }
    }

    console.log("handleSceneResponse() - Ï≤òÎ¶¨ ÏôÑÎ£å: sceneResponses=", gameState.sceneResponses, "sceneErrors=", gameState.sceneErrors, "sceneTargetProcessed=", gameState.sceneTargetProcessed);
}











function handleLocationResponse() {
    if (gameState.isPaused) return; // Í≤åÏûÑÏù¥ ÏùºÏãú Ï†ïÏßÄÎêú Í≤ΩÏö∞ Ï≤òÎ¶¨ Ï§ëÎã®
    console.log("handleLocationResponse() - Ï≤òÎ¶¨ ÏãúÏûë: canRespondLocation=", gameState.canRespondLocation, "locationTargetProcessed=", gameState.locationTargetProcessed, "currentStimulus=", gameState.currentStimulus);

    console.log("handleLocationResponse() - ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú:", {
        currentIsLocationTarget: gameState.currentIsLocationTarget,
        inResponseWindow: gameState.inResponseWindow
    });

    if (!gameState.canRespondLocation || gameState.locationTargetProcessed) {
        console.log("handleLocationResponse() - ÏùëÎãµ Ï∞®Îã®: canRespondLocation=", gameState.canRespondLocation, "locationTargetProcessed=", gameState.locationTargetProcessed);
        return; // ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä ÎòêÎäî Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Í≤ΩÏö∞ Ï§ëÎã®
    }

    gameState.locationTargetProcessed = true; // ÏúÑÏπò ÏùëÎãµ Ï≤òÎ¶¨ ÏôÑÎ£å ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
    gameState.canRespondLocation = false; // Ï∂îÍ∞Ä ÏùëÎãµ Î∞©ÏßÄ
    if (gameState.currentStimulus <= gameState.nBackLevel) {
        showEarlyResponseFeedback('location-indicator'); // Ï°∞Í∏∞ ÏùëÎãµ ÌîºÎìúÎ∞± ÌëúÏãú
        console.log("handleLocationResponse() - Ï°∞Í∏∞ ÏùëÎãµ: stimulus=", gameState.currentStimulus, "nBackLevel=", gameState.nBackLevel);
        return; // NÎ∞± Î†àÎ≤® Ïù¥Ï†Ñ ÏûêÍ∑πÏù¥Î©¥ Ï°∞Í∏∞ ÏùëÎãµÏúºÎ°ú Ï≤òÎ¶¨
    }

    gameState.locationResponses++; // ÏúÑÏπò ÏùëÎãµ ÌöüÏàò Ï¶ùÍ∞Ä
    const currentPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1]; // ÌòÑÏû¨ ÏûêÍ∑π Ï†ïÎ≥¥
    const nBackPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1 - gameState.nBackLevel]; // NÎ∞± Ïù¥Ï†Ñ ÏûêÍ∑π Ï†ïÎ≥¥
    const sequenceTarget = gameState.stimulusSequence[gameState.currentStimulus - 1]; // ÏãúÌÄÄÏä§ÏóêÏÑú Ï†ïÏùòÎêú ÌÉÄÍ≤ü Ï†ïÎ≥¥

    console.log("handleLocationResponse() - ÏúÑÏπò ÎπÑÍµê: ÌòÑÏû¨ panelIndex=", currentPresented.panelIndex, "NÎ∞± panelIndex=", nBackPresented.panelIndex);

    const isCorrect = currentPresented.panelIndex === nBackPresented.panelIndex; // ÎèôÏ†Å ÌÉÄÍ≤ü ÌåêÏ†ï
    console.log("handleLocationResponse() - ÌÉÄÍ≤ü Í≤ÄÏ¶ù:", {
        predefined: gameState.currentIsLocationTarget,
        dynamic: isCorrect,
        match: gameState.currentIsLocationTarget === isCorrect,
        sequenceIsTarget: sequenceTarget.isLocationTarget // ÏãúÌÄÄÏä§ ÌÉÄÍ≤ü Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    });

    // ÌÉÄÍ≤ü ÌåêÏ†ï Ï†ïÎ∞ÄÌôî: ÏãúÌÄÄÏä§ ÌÉÄÍ≤üÍ≥º ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò ÌôïÏù∏
    if (gameState.currentIsLocationTarget !== sequenceTarget.isLocationTarget) {
        console.log("%c[Î∂ÑÏÑù] ÏúÑÏπò ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò: currentIsLocationTargetÏôÄ ÏãúÌÄÄÏä§ Í∞íÏù¥ Îã§Î¶Ñ", "color: orange");
    }

    showIndicatorFeedback('location-indicator', gameState.currentIsLocationTarget && isCorrect); // UI ÌîºÎìúÎ∞± ÌëúÏãú

    // Î∂ÑÏÑù Î°úÏßÅ Í∞ïÌôî
    if (gameState.currentIsLocationTarget) {
        if (!isCorrect) {
            gameState.locationErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            gameState.targetMissedErrors.location++; // ÌÉÄÍ≤ü ÎÜìÏπ® Ïò§Î•ò Ï¶ùÍ∞Ä
            console.log("handleLocationResponse() - ÏúÑÏπò Ïò§Î•ò (ÌÉÄÍ≤ü ÎÜìÏπ®): locationErrors=", gameState.locationErrors, "isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤ü ÏúÑÏπò ÏûêÍ∑πÏóê Î∞òÏùëÌñàÏúºÎÇò Ïò§Îãµ Ï≤òÎ¶¨Îê® - NÎ∞± ÎπÑÍµê Ïã§Ìå®", "color: red");
            console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.panelIndex, "NÎ∞±=", nBackPresented.panelIndex);
        } else {
            console.log("handleLocationResponse() - ÏúÑÏπò Ï†ïÎãµ: isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÌÉÄÍ≤ü ÏúÑÏπò ÏûêÍ∑πÏóê Ï†ïÌôïÌûà Î∞òÏùëÌï®", "color: green");
        }
    } else {
        gameState.locationErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
        gameState.nonTargetFalseResponses.location++; // ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë Ï¶ùÍ∞Ä
        console.log("handleLocationResponse() - ÏúÑÏπò Ïò§Î•ò (ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë): locationErrors=", gameState.locationErrors);
        console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤üÏù¥ ÏïÑÎãå ÏúÑÏπò ÏûêÍ∑πÏùÑ ÌÉÄÍ≤üÏúºÎ°ú Ïò§Î∞òÏùëÌï®", "color: red");
        console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.panelIndex, "NÎ∞±=", nBackPresented.panelIndex);
        if (currentPresented.isNearMiss) {
            gameState.nearMissResponses++; // ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            console.log("handleLocationResponse() - ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Í∞êÏßÄ: nearMissResponses=", gameState.nearMissResponses);
            console.log("%c[Î∂ÑÏÑù] ÎãàÏñºÎØ∏Ïä§ ÏûêÍ∑πÏóê Î∞òÏùëÌï® - ÌòºÎèô Ïú†Î∞ú Í∞ÄÎä•ÏÑ±", "color: yellow");
        }
    }

    console.log("handleLocationResponse() - Ï≤òÎ¶¨ ÏôÑÎ£å: locationResponses=", gameState.locationResponses, "locationErrors=", gameState.locationErrors, "locationTargetProcessed=", gameState.locationTargetProcessed);
}









function handleSoundResponse() {
    if (gameState.isPaused) return; // Í≤åÏûÑÏù¥ ÏùºÏãú Ï†ïÏßÄÎêú Í≤ΩÏö∞ Ï≤òÎ¶¨ Ï§ëÎã®
    console.log("handleSoundResponse() - Ï≤òÎ¶¨ ÏãúÏûë: canRespondSound=", gameState.canRespondSound, "soundTargetProcessed=", gameState.soundTargetProcessed, "currentStimulus=", gameState.currentStimulus);

    console.log("handleSoundResponse() - ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú:", {
        currentIsSoundTarget: gameState.currentIsSoundTarget,
        inResponseWindow: gameState.inResponseWindow
    });

    if (!gameState.canRespondSound || gameState.soundTargetProcessed) {
        console.log("handleSoundResponse() - ÏùëÎãµ Ï∞®Îã®: canRespondSound=", gameState.canRespondSound, "soundTargetProcessed=", gameState.soundTargetProcessed);
        return; // ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä ÎòêÎäî Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Í≤ΩÏö∞ Ï§ëÎã®
    }

    gameState.soundTargetProcessed = true; // ÏÜåÎ¶¨ ÏùëÎãµ Ï≤òÎ¶¨ ÏôÑÎ£å ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
    gameState.canRespondSound = false; // Ï∂îÍ∞Ä ÏùëÎãµ Î∞©ÏßÄ
    if (gameState.currentStimulus <= gameState.nBackLevel) {
        showEarlyResponseFeedback('sound-indicator'); // Ï°∞Í∏∞ ÏùëÎãµ ÌîºÎìúÎ∞± ÌëúÏãú
        console.log("handleSoundResponse() - Ï°∞Í∏∞ ÏùëÎãµ: stimulus=", gameState.currentStimulus, "nBackLevel=", gameState.nBackLevel);
        return; // NÎ∞± Î†àÎ≤® Ïù¥Ï†Ñ ÏûêÍ∑πÏù¥Î©¥ Ï°∞Í∏∞ ÏùëÎãµÏúºÎ°ú Ï≤òÎ¶¨
    }

    gameState.soundResponses++; // ÏÜåÎ¶¨ ÏùëÎãµ ÌöüÏàò Ï¶ùÍ∞Ä
    const currentPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1]; // ÌòÑÏû¨ ÏûêÍ∑π Ï†ïÎ≥¥
    const nBackPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1 - gameState.nBackLevel]; // NÎ∞± Ïù¥Ï†Ñ ÏûêÍ∑π Ï†ïÎ≥¥
    const sequenceTarget = gameState.stimulusSequence[gameState.currentStimulus - 1]; // ÏãúÌÄÄÏä§ÏóêÏÑú Ï†ïÏùòÎêú ÌÉÄÍ≤ü Ï†ïÎ≥¥

    console.log("handleSoundResponse() - ÏÜåÎ¶¨ ÎπÑÍµê: ÌòÑÏû¨ soundIndex=", currentPresented.soundIndex, "NÎ∞± soundIndex=", nBackPresented.soundIndex);

    const isCorrect = currentPresented.soundIndex === nBackPresented.soundIndex; // ÎèôÏ†Å ÌÉÄÍ≤ü ÌåêÏ†ï
    console.log("handleSoundResponse() - ÌÉÄÍ≤ü Í≤ÄÏ¶ù:", {
        predefined: gameState.currentIsSoundTarget,
        dynamic: isCorrect,
        match: gameState.currentIsSoundTarget === isCorrect,
        sequenceIsTarget: sequenceTarget.isSoundTarget // ÏãúÌÄÄÏä§ ÌÉÄÍ≤ü Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    });

    // ÌÉÄÍ≤ü ÌåêÏ†ï Ï†ïÎ∞ÄÌôî: ÏãúÌÄÄÏä§ ÌÉÄÍ≤üÍ≥º ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò ÌôïÏù∏
    if (gameState.currentIsSoundTarget !== sequenceTarget.isSoundTarget) {
        console.log("%c[Î∂ÑÏÑù] ÏÜåÎ¶¨ ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò: currentIsSoundTargetÏôÄ ÏãúÌÄÄÏä§ Í∞íÏù¥ Îã§Î¶Ñ", "color: orange");
    }

    showIndicatorFeedback('sound-indicator', gameState.currentIsSoundTarget && isCorrect); // UI ÌîºÎìúÎ∞± ÌëúÏãú

    // Î∂ÑÏÑù Î°úÏßÅ Í∞ïÌôî
    if (gameState.currentIsSoundTarget) {
        if (!isCorrect) {
            gameState.soundErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            gameState.targetMissedErrors.sound++; // ÌÉÄÍ≤ü ÎÜìÏπ® Ïò§Î•ò Ï¶ùÍ∞Ä
            console.log("handleSoundResponse() - ÏÜåÎ¶¨ Ïò§Î•ò (ÌÉÄÍ≤ü ÎÜìÏπ®): soundErrors=", gameState.soundErrors, "isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤ü ÏÜåÎ¶¨ ÏûêÍ∑πÏóê Î∞òÏùëÌñàÏúºÎÇò Ïò§Îãµ Ï≤òÎ¶¨Îê® - NÎ∞± ÎπÑÍµê Ïã§Ìå®", "color: red");
            console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.soundIndex, "NÎ∞±=", nBackPresented.soundIndex);
        } else {
            console.log("handleSoundResponse() - ÏÜåÎ¶¨ Ï†ïÎãµ: isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÌÉÄÍ≤ü ÏÜåÎ¶¨ ÏûêÍ∑πÏóê Ï†ïÌôïÌûà Î∞òÏùëÌï®", "color: green");
        }
    } else {
        gameState.soundErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
        gameState.nonTargetFalseResponses.sound++; // ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë Ï¶ùÍ∞Ä
        console.log("handleSoundResponse() - ÏÜåÎ¶¨ Ïò§Î•ò (ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë): soundErrors=", gameState.soundErrors);
        console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤üÏù¥ ÏïÑÎãå ÏÜåÎ¶¨ ÏûêÍ∑πÏùÑ ÌÉÄÍ≤üÏúºÎ°ú Ïò§Î∞òÏùëÌï®", "color: red");
        console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.soundIndex, "NÎ∞±=", nBackPresented.soundIndex);
        if (currentPresented.isNearMiss) {
            gameState.nearMissResponses++; // ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            console.log("handleSoundResponse() - ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Í∞êÏßÄ: nearMissResponses=", gameState.nearMissResponses);
            console.log("%c[Î∂ÑÏÑù] ÎãàÏñºÎØ∏Ïä§ ÏûêÍ∑πÏóê Î∞òÏùëÌï® - ÌòºÎèô Ïú†Î∞ú Í∞ÄÎä•ÏÑ±", "color: yellow");
        }
    }

    console.log("handleSoundResponse() - Ï≤òÎ¶¨ ÏôÑÎ£å: soundResponses=", gameState.soundResponses, "soundErrors=", gameState.soundErrors, "soundTargetProcessed=", gameState.soundTargetProcessed);
}





function handleColorResponse() {
    if (gameState.isPaused) return; // Í≤åÏûÑÏù¥ ÏùºÏãú Ï†ïÏßÄÎêú Í≤ΩÏö∞ Ï≤òÎ¶¨ Ï§ëÎã®
    console.log("handleColorResponse() - Ï≤òÎ¶¨ ÏãúÏûë: canRespondColor=", gameState.canRespondColor, "colorTargetProcessed=", gameState.colorTargetProcessed, "currentStimulus=", gameState.currentStimulus);

    console.log("handleColorResponse() - ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú:", {
        currentIsColorTarget: gameState.currentIsColorTarget,
        inResponseWindow: gameState.inResponseWindow
    });

    if (!gameState.canRespondColor || gameState.colorTargetProcessed) {
        console.log("handleColorResponse() - ÏùëÎãµ Ï∞®Îã®: canRespondColor=", gameState.canRespondColor, "colorTargetProcessed=", gameState.colorTargetProcessed);
        return; // ÏùëÎãµ Í∞ÄÎä• Ïó¨Î∂Ä ÎòêÎäî Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Í≤ΩÏö∞ Ï§ëÎã®
    }

    gameState.colorTargetProcessed = true; // ÏÉâÏÉÅ ÏùëÎãµ Ï≤òÎ¶¨ ÏôÑÎ£å ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
    gameState.canRespondColor = false; // Ï∂îÍ∞Ä ÏùëÎãµ Î∞©ÏßÄ
    if (gameState.currentStimulus <= gameState.nBackLevel) {
        showEarlyResponseFeedback('color-indicator'); // Ï°∞Í∏∞ ÏùëÎãµ ÌîºÎìúÎ∞± ÌëúÏãú
        console.log("handleColorResponse() - Ï°∞Í∏∞ ÏùëÎãµ: stimulus=", gameState.currentStimulus, "nBackLevel=", gameState.nBackLevel);
        return; // NÎ∞± Î†àÎ≤® Ïù¥Ï†Ñ ÏûêÍ∑πÏù¥Î©¥ Ï°∞Í∏∞ ÏùëÎãµÏúºÎ°ú Ï≤òÎ¶¨
    }

    gameState.colorResponses++; // ÏÉâÏÉÅ ÏùëÎãµ ÌöüÏàò Ï¶ùÍ∞Ä
    const currentPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1]; // ÌòÑÏû¨ ÏûêÍ∑π Ï†ïÎ≥¥
    const nBackPresented = gameState.presentedStimulusHistory[gameState.currentStimulus - 1 - gameState.nBackLevel]; // NÎ∞± Ïù¥Ï†Ñ ÏûêÍ∑π Ï†ïÎ≥¥
    const sequenceTarget = gameState.stimulusSequence[gameState.currentStimulus - 1]; // ÏãúÌÄÄÏä§ÏóêÏÑú Ï†ïÏùòÎêú ÌÉÄÍ≤ü Ï†ïÎ≥¥

    console.log("handleColorResponse() - ÏÉâÏÉÅ ÎπÑÍµê: ÌòÑÏû¨ colorIndex=", currentPresented.colorIndex, "NÎ∞± colorIndex=", nBackPresented.colorIndex);

    const isCorrect = currentPresented.colorIndex === nBackPresented.colorIndex; // ÎèôÏ†Å ÌÉÄÍ≤ü ÌåêÏ†ï
    console.log("handleColorResponse() - ÌÉÄÍ≤ü Í≤ÄÏ¶ù:", {
        predefined: gameState.currentIsColorTarget,
        dynamic: isCorrect,
        match: gameState.currentIsColorTarget === isCorrect,
        sequenceIsTarget: sequenceTarget.isColorTarget // ÏãúÌÄÄÏä§ ÌÉÄÍ≤ü Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    });

    // ÌÉÄÍ≤ü ÌåêÏ†ï Ï†ïÎ∞ÄÌôî: ÏãúÌÄÄÏä§ ÌÉÄÍ≤üÍ≥º ÌòÑÏû¨ ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò ÌôïÏù∏
    if (gameState.currentIsColorTarget !== sequenceTarget.isColorTarget) {
        console.log("%c[Î∂ÑÏÑù] ÏÉâÏÉÅ ÌÉÄÍ≤ü ÏÉÅÌÉú Î∂àÏùºÏπò: currentIsColorTargetÏôÄ ÏãúÌÄÄÏä§ Í∞íÏù¥ Îã§Î¶Ñ", "color: orange");
    }

    showIndicatorFeedback('color-indicator', gameState.currentIsColorTarget && isCorrect); // UI ÌîºÎìúÎ∞± ÌëúÏãú

    // Î∂ÑÏÑù Î°úÏßÅ Í∞ïÌôî
    if (gameState.currentIsColorTarget) {
        if (!isCorrect) {
            gameState.colorErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            gameState.targetMissedErrors.color++; // ÌÉÄÍ≤ü ÎÜìÏπ® Ïò§Î•ò Ï¶ùÍ∞Ä
            console.log("handleColorResponse() - ÏÉâÏÉÅ Ïò§Î•ò (ÌÉÄÍ≤ü ÎÜìÏπ®): colorErrors=", gameState.colorErrors, "isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤ü ÏÉâÏÉÅ ÏûêÍ∑πÏóê Î∞òÏùëÌñàÏúºÎÇò Ïò§Îãµ Ï≤òÎ¶¨Îê® - NÎ∞± ÎπÑÍµê Ïã§Ìå®", "color: red");
            console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.colorIndex, "NÎ∞±=", nBackPresented.colorIndex);
        } else {
            console.log("handleColorResponse() - ÏÉâÏÉÅ Ï†ïÎãµ: isCorrect=", isCorrect);
            console.log("%c[Î∂ÑÏÑù] ÌÉÄÍ≤ü ÏÉâÏÉÅ ÏûêÍ∑πÏóê Ï†ïÌôïÌûà Î∞òÏùëÌï®", "color: green");
        }
    } else {
        gameState.colorErrors++; // Ïò§Î•ò Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
        gameState.nonTargetFalseResponses.color++; // ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë Ï¶ùÍ∞Ä
        console.log("handleColorResponse() - ÏÉâÏÉÅ Ïò§Î•ò (ÎÖºÌÉÄÍ≤ü Ïò§Î∞òÏùë): colorErrors=", gameState.colorErrors);
        console.log("%c[Î∂ÑÏÑù] ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÉÄÍ≤üÏù¥ ÏïÑÎãå ÏÉâÏÉÅ ÏûêÍ∑πÏùÑ ÌÉÄÍ≤üÏúºÎ°ú Ïò§Î∞òÏùëÌï®", "color: red");
        console.log("ÏÉÅÏÑ∏: ÌòÑÏû¨=", currentPresented.colorIndex, "NÎ∞±=", nBackPresented.colorIndex);
        if (currentPresented.isNearMiss) {
            gameState.nearMissResponses++; // ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
            console.log("handleColorResponse() - ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë Í∞êÏßÄ: nearMissResponses=", gameState.nearMissResponses);
            console.log("%c[Î∂ÑÏÑù] ÎãàÏñºÎØ∏Ïä§ ÏûêÍ∑πÏóê Î∞òÏùëÌï® - ÌòºÎèô Ïú†Î∞ú Í∞ÄÎä•ÏÑ±", "color: yellow");
        }
    }

    console.log("handleColorResponse() - Ï≤òÎ¶¨ ÏôÑÎ£å: colorResponses=", gameState.colorResponses, "colorErrors=", gameState.colorErrors, "colorTargetProcessed=", gameState.colorTargetProcessed);
}







function setTargetGoal(type, baseValue) {
    if (!Number.isInteger(baseValue) || baseValue < 0) {
        console.error(`setTargetGoal() - ÏûòÎ™ªÎêú ÌÉÄÍ≤ü Î™©Ìëú Í∞í: ${type}=${baseValue}`);
        baseValue = 0; // Í∏∞Î≥∏Í∞íÏúºÎ°ú 0 ÏÑ§Ï†ï
    }
    // ÏµúÎåÄ ÌÉÄÍ≤ü ÏàòÎäî stimuliPerBlockÍ≥º nBackLevelÏùÑ Í≥†Î†§Ìï¥ Ï†úÌïú
    const maxTargets = Math.floor((gameState.stimuliPerBlock - gameState.nBackLevel) / (gameState.nBackLevel + 1));
    const adjustedValue = Math.max(0, Math.min(baseValue, maxTargets));
    gameState.targetCountGoals[type] = adjustedValue;
    console.log(`setTargetGoal() - ${type} ÌÉÄÍ≤ü Î™©Ìëú ÏÑ§Ï†ï: ÏûÖÎ†•Í∞í=${baseValue}, Ï°∞Ï†ïÍ∞í=${adjustedValue}, ÏµúÎåÄ Í∞ÄÎä•=${maxTargets}`);
}

function startBlock() {
    console.log("startBlock() - ÏÉàÎ°úÏö¥ Î∏îÎ°ù ÏãúÏûë, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());
    gameState.isPlaying = true;
    gameState.isPaused = false;
    gameState.currentStimulus = 0;
    gameState.sceneTargets = 0;
    gameState.locationTargets = 0;
    gameState.soundTargets = 0;
    gameState.colorTargets = 0;
    gameState.bothTargets = 0;
    gameState.sceneErrors = 0;
    gameState.locationErrors = 0;
    gameState.soundErrors = 0;
    gameState.colorErrors = 0;
    gameState.sceneHistory = [];
    gameState.locationHistory = [];
    gameState.soundHistory = [];
    gameState.colorHistory = [];
    gameState.recentSceneIndices = [];
    gameState.recentLocationIndices = [];
    gameState.recentSoundIndices = [];
    gameState.recentColorIndices = [];
    gameState.recentTargetTypes = [];
    gameState.recentInterferenceCount = 0;
    gameState.presentedStimulusHistory = [];
    nearMissHistory = []; // ÎãàÏñºÎØ∏Ïä§ Í∏∞Î°ù Ï¥àÍ∏∞Ìôî
    console.log("startBlock() - nearMissHistory Ï¥àÍ∏∞Ìôî ÏôÑÎ£å, Í∏∏Ïù¥:", nearMissHistory.length);

    // ÎèôÏ†Å ÌÉÄÍ≤ü Î™©Ìëú ÏÑ§Ï†ï
    setTargetGoal("scene", Math.ceil(3 * (gameState.nBackLevel / 2)));
    setTargetGoal("location", Math.ceil(3 * (gameState.nBackLevel / 2)));
    setTargetGoal("sound", Math.ceil(1 * (gameState.nBackLevel / 2)));
    setTargetGoal("color", Math.ceil(3 * (gameState.nBackLevel / 2)));

    gameState.stimulusSequence = generateStimulusSequence();

    // UI Ï†ÑÌôò
    console.log("startBlock() - DOM ÏöîÏÜå ÌôïÏù∏ ÌõÑ UI Ï†ÑÌôò ÏãúÏûë");
    const titleScreen = document.getElementById('titleScreen');
    const gameScreen = document.getElementById('gameScreen');
    const blockCount = document.getElementById('blockCount');

    if (!titleScreen || !gameScreen || !blockCount) {
        console.error("startBlock() - ÌïÑÏàò UI ÏöîÏÜå ÎàÑÎùΩ:", {
            titleScreen: titleScreen ? "Î∞úÍ≤¨" : "ÎàÑÎùΩ",
            gameScreen: gameScreen ? "Î∞úÍ≤¨" : "ÎàÑÎùΩ",
            blockCount: blockCount ? "Î∞úÍ≤¨" : "ÎàÑÎùΩ"
        });
        return;
    }

    titleScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    blockCount.textContent = gameState.currentBlock;
    blockCount.style.display = 'none';

    document.getElementById('totalGamesTodayCountValue').textContent = gameState.totalGamesToday;

    // Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÌëúÏãú
    sceneIndicator.style.display = gameState.stimulusTypes.includes("scene") ? 'flex' : 'none';
    soundIndicator.style.display = gameState.stimulusTypes.includes("sound") ? 'flex' : 'none';
    locationIndicator.style.display = gameState.stimulusTypes.includes("location") ? 'flex' : 'none';
    colorIndicator.style.display = gameState.stimulusTypes.includes("color") ? 'flex' : 'none';

    // 1Ï¥à ÌõÑÏóê Ï≤´ ÏûêÍ∑π Ï†úÏãú
    setTimeout(() => {
        if (!gameState.isPaused) {
            generateNextStimulus();
            console.log("startBlock() - 1Ï¥à ÌõÑ Ï≤´ ÏûêÍ∑π Ï†úÏãú ÏôÑÎ£å, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());
        } else {
            console.log("startBlock() - ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉúÎ°ú Ïù∏Ìï¥ Ï≤´ ÏûêÍ∑π Ï†úÏãú ÏÉùÎûµ:", {
                isPaused: gameState.isPaused
            });
        }
    }, 1000);
}






















function generateStimulusSequence() {
    console.log("generateStimulusSequence() - ÏãúÌÄÄÏä§ ÏÉùÏÑ± ÏãúÏûë: ÏÉàÎ°úÏö¥ Ìå®ÌÑ¥Î∞©ÏßÄ Î∞è ÎãàÏñºÎØ∏Ïä§ Î°úÏßÅ Ï†ÅÏö©");
    console.log("generateStimulusSequence() - nearMissHistory Ï¥àÍ∏∞Ìôî ÏÉÅÌÉú ÌôïÏù∏, Í∏∏Ïù¥:", nearMissHistory.length);
    const sequence = [];
    const recentLimit = gameState.nBackLevel * 2;
    const targetGoals = { scene: 3, location: 3, sound: 2, color: 3 };
    const targetPositions = {};
    const targetTypes = ['scene', 'location', 'sound', 'color'];

    const patternPreventionStrength = gameState.patternPreventionStrength;
    const minTargetInterval = gameState.minTargetInterval;
    const maxTargetInterval = Math.min(gameState.maxTargetInterval, gameState.stimuliPerBlock - gameState.nBackLevel - 1);
    const totalStimuli = gameState.stimuliPerBlock - gameState.nBackLevel;

    targetTypes.forEach(type => {
        targetPositions[type] = selectTargetPositions(totalStimuli, targetGoals[type], minTargetInterval, maxTargetInterval, patternPreventionStrength);
        console.log(`generateStimulusSequence() - ${type} ÌÉÄÍ≤ü ÏúÑÏπò:`, targetPositions[type]);
    });

    // Ï¥àÍ∏∞ ÏûêÍ∑π ÏÉùÏÑ± (NÎ∞± Î†àÎ≤®ÎßåÌÅº)
    for (let i = 0; i < gameState.nBackLevel; i++) {
        const imageIndex = selectIndexAvoidingRecent(gameState.recentSceneIndices || [], imageTextures.length, recentLimit, 5);
        const panelIndex = selectIndexAvoidingRecent(gameState.recentLocationIndices || [], panels.length, recentLimit, 5);
        const soundIndex = selectIndexAvoidingRecent(gameState.recentSoundIndices || [], gameState.pianoTones.length, recentLimit, 5);
        const colorIndex = selectIndexAvoidingRecent(gameState.recentColorIndices || [], distinctColors.length, recentLimit, 5);

        sequence.push({
            imageIndex, panelIndex, soundIndex, colorIndex,
            targetType: "initial",
            isSceneTarget: false, isLocationTarget: false, isSoundTarget: false, isColorTarget: false,
            isNearMiss: false
        });
        updateRecentIndices("scene", imageIndex, recentLimit);
        updateRecentIndices("location", panelIndex, recentLimit);
        updateRecentIndices("sound", soundIndex, recentLimit);
        updateRecentIndices("color", colorIndex, recentLimit);
    }

    const allTargets = [];
    targetTypes.forEach(type => {
        targetPositions[type].forEach(pos => allTargets.push({ pos, type }));
    });
    allTargets.sort((a, b) => a.pos - b.pos);

    const nearMissTypes = ['N-1', 'N+1', '2N'];
    const n = gameState.nBackLevel; // NÎ∞± Î†àÎ≤®

    let consecutiveNonTargets = 0; // Ïó∞ÏÜçÎêú non-target ÏûêÍ∑π Ïàò Ï∂îÏ†Å

    // ÏûêÍ∑π ÏãúÌÄÄÏä§ ÏÉùÏÑ±
    for (let i = 0; i < totalStimuli; i++) {
        const absoluteIndex = i + gameState.nBackLevel;
        const nBackIndex = absoluteIndex - gameState.nBackLevel;
        const targetsAtPos = allTargets.filter(t => t.pos === absoluteIndex); // Î≥µÍµ¨: absoluteIndex ÏÇ¨Ïö©

        // ÌÉÄÍ≤ü ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (ÏõêÎ≥∏ Î°úÏßÅ Ïú†ÏßÄ)
        let isSceneTarget = targetsAtPos.some(t => t.type === 'scene');
        let isLocationTarget = targetsAtPos.some(t => t.type === 'location');
        let isSoundTarget = targetsAtPos.some(t => t.type === 'sound');
        let isColorTarget = targetsAtPos.some(t => t.type === 'color');
        let targetType = targetsAtPos.length ? targetsAtPos[0].type : "non-target";

        // Ïó∞ÏÜçÎêú non-target ÏûêÍ∑π Ï†úÌïú (ÌÉÄÍ≤ü ÏúÑÏπòÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Ï†ÅÏö©)
        if (!targetsAtPos.length && consecutiveNonTargets >= 2) {
            console.log(`generateStimulusSequence() - Ïó∞ÏÜç non-target 2Ìöå Ï¥àÍ≥º Í∞êÏßÄ at ${absoluteIndex}, Í∞ïÏ†ú ÌÉÄÍ≤ü ÏÇΩÏûÖ`);
            const type = targetTypes[Math.floor(Math.random() * targetTypes.length)];
            if (type === 'scene') isSceneTarget = true;
            else if (type === 'location') isLocationTarget = true;
            else if (type === 'sound') isSoundTarget = true;
            else if (type === 'color') isColorTarget = true;
            targetType = type;
            consecutiveNonTargets = 0;
        }

        // ÌÉÄÍ≤ü ÏÉùÏÑ± Î°úÏßÅ (ÏõêÎ≥∏ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ)
        let imageIndex = isSceneTarget ? sequence[nBackIndex].imageIndex : selectIndexAvoidingRecent(gameState.recentSceneIndices, imageTextures.length, recentLimit, 5);
        let panelIndex = isLocationTarget ? sequence[nBackIndex].panelIndex : selectIndexAvoidingRecent(gameState.recentLocationIndices, panels.length, recentLimit, 5);
        let soundIndex = isSoundTarget ? sequence[nBackIndex].soundIndex : selectIndexAvoidingRecent(gameState.recentSoundIndices, gameState.pianoTones.length, recentLimit, 5);
        let colorIndex = isColorTarget ? sequence[nBackIndex].colorIndex : selectIndexAvoidingRecent(gameState.recentColorIndices, distinctColors.length, recentLimit, 5);

        // ÎãàÏñºÎØ∏Ïä§ ÏÉùÏÑ± Î°úÏßÅ (ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ Ï†úÏô∏ÌïòÍ≥† ÏõêÎ≥∏ Ïú†ÏßÄ)
        let isNearMiss = false;
        if (n > 1 && !isSceneTarget && !isLocationTarget && !isSoundTarget && !isColorTarget) { // N=1Ïùº Îïå ÎãàÏñºÎØ∏Ïä§ ÎπÑÌôúÏÑ±Ìôî
            const previousStimulus = sequence[absoluteIndex - 1];
            const isPreviousNearMiss = previousStimulus && previousStimulus.isNearMiss;
            const distanceToNearestTarget = Math.min(
                ...allTargets.map(t => Math.abs(t.pos - absoluteIndex))
            );
            if (!isPreviousNearMiss && distanceToNearestTarget > 1 && Math.random() < gameState.nearMissProbability) {
                isNearMiss = true;
                const nearMissType = nearMissTypes[Math.floor(Math.random() * nearMissTypes.length)];
                console.log(`generateStimulusSequence() - ÎãàÏñºÎØ∏Ïä§ ÏÉùÏÑ± ÏãúÎèÑ: ÏúÑÏπò=${absoluteIndex}, Ïú†Ìòï=${nearMissType}, ÌôïÎ•†=${gameState.nearMissProbability}`);

                // ÎãàÏñºÎØ∏Ïä§ Ïú†ÌòïÏóê Îî∞Î•∏ Ïù∏Îç±Ïä§ ÏÑ§Ï†ï
                if (nearMissType === 'N-1' && absoluteIndex - 1 >= 0) {
                    imageIndex = sequence[absoluteIndex - 1].imageIndex;
                    panelIndex = sequence[absoluteIndex - 1].panelIndex;
                    soundIndex = sequence[absoluteIndex - 1].soundIndex;
                    colorIndex = sequence[absoluteIndex - 1].colorIndex;
                } else if (nearMissType === 'N+1' && absoluteIndex + 1 < gameState.stimuliPerBlock) {
                    const nextStimulus = generateNextStimulusPreview(absoluteIndex + 1, sequence, allTargets);
                    imageIndex = nextStimulus.imageIndex;
                    panelIndex = nextStimulus.panelIndex;
                    soundIndex = nextStimulus.soundIndex;
                    colorIndex = nextStimulus.colorIndex;
                } else if (nearMissType === '2N' && absoluteIndex - 2 * gameState.nBackLevel >= 0) {
                    imageIndex = sequence[absoluteIndex - 2 * gameState.nBackLevel].imageIndex;
                    panelIndex = sequence[absoluteIndex - 2 * gameState.nBackLevel].panelIndex;
                    soundIndex = sequence[absoluteIndex - 2 * gameState.nBackLevel].soundIndex;
                    colorIndex = sequence[absoluteIndex - 2 * gameState.nBackLevel].colorIndex;
                }

                // ÎãàÏñºÎØ∏Ïä§Í∞Ä NÎ∞± ÏûêÍ∑πÍ≥º ÎèôÏùºÌïòÏßÄ ÏïäÎèÑÎ°ù Í≤ÄÏ¶ù
                const nBackStimulus = sequence[nBackIndex];
                const isValidNearMiss = !(
                    imageIndex === nBackStimulus.imageIndex &&
                    panelIndex === nBackStimulus.panelIndex &&
                    soundIndex === nBackStimulus.soundIndex &&
                    colorIndex === nBackStimulus.colorIndex
                );

                if (!isValidNearMiss) {
                    console.log(`%c[Í≤ΩÍ≥†] ÏúÑÏπò ${absoluteIndex}: ÎãàÏñºÎØ∏Ïä§Í∞Ä NÎ∞± ÌÉÄÍ≤üÍ≥º ÎèôÏùºÌïòÏó¨ ÏÉùÏÑ± Ï∑®ÏÜå`, 'color: red');
                    isNearMiss = false;
                } else {
                    nearMissHistory.push({ type: nearMissType, index: absoluteIndex });
                    console.log(`generateStimulusSequence() - ÎãàÏñºÎØ∏Ïä§ ÏÉùÏÑ± ÏÑ±Í≥µ: ÏúÑÏπò=${absoluteIndex}, Ïú†Ìòï=${nearMissType}, nearMissHistory Í∏∏Ïù¥=${nearMissHistory.length}`);
                }
            }
        }

        // ÏãúÌÄÄÏä§Ïóê ÏûêÍ∑π Ï∂îÍ∞Ä
        sequence.push({
            imageIndex, panelIndex, soundIndex, colorIndex,
            targetType, isSceneTarget, isLocationTarget, isSoundTarget, isColorTarget,
            isNearMiss
        });

        // Ïó∞ÏÜç non-target Ï∂îÏ†Å
        if (!isSceneTarget && !isLocationTarget && !isSoundTarget && !isColorTarget) {
            consecutiveNonTargets++;
            console.log(`generateStimulusSequence() - non-target Ïó∞ÏÜç ÌöüÏàò: ${consecutiveNonTargets} at ${absoluteIndex}`);
        } else {
            consecutiveNonTargets = 0;
            console.log(`generateStimulusSequence() - ÌÉÄÍ≤ü ÏÇΩÏûÖÏúºÎ°ú non-target Ïó∞ÏÜç Ï¥àÍ∏∞Ìôî at ${absoluteIndex}`);
        }

        updateRecentIndices("scene", imageIndex, recentLimit);
        updateRecentIndices("location", panelIndex, recentLimit);
        updateRecentIndices("sound", soundIndex, recentLimit);
        updateRecentIndices("color", colorIndex, recentLimit);
    }

    console.log("generateStimulusSequence() - [Î∂ÑÏÑù] ÏãúÌÄ∏Ïä§ ÏÉùÏÑ± ÏôÑÎ£å: Í∏∏Ïù¥=", sequence.length, "ÎãàÏñºÎØ∏Ïä§ Í∞úÏàò=", nearMissHistory.length);

    // ÎîîÎ≤ÑÍπÖ: ÏÉùÏÑ±Îêú ÏãúÌÄÄÏä§Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂úÎ†•
    console.log("%c[ÏãúÌÄÄÏä§ ÏÉùÏÑ±] Ï†ÑÏ≤¥ ÏãúÌÄÄÏä§ Í∏∏Ïù¥: " + sequence.length, "color: blue");
    console.log("%c[ÏãúÌÄÄÏä§ ÏÉùÏÑ±] ÏÉùÏÑ±Îêú ÏãúÌÄÄÏä§ ÎÇ¥Ïö©:", "color: blue", sequence.map((s, idx) => ({
        index: idx,
        targetType: s.targetType,
        imageIndex: s.imageIndex,
        panelIndex: s.panelIndex,
        soundIndex: s.soundIndex,
        colorIndex: s.colorIndex,
        isSceneTarget: s.isSceneTarget,
        isLocationTarget: s.isLocationTarget,
        isSoundTarget: s.isSoundTarget,
        isColorTarget: s.isColorTarget
    })));

    // ÏÜçÏÑ±Í∞í ÎπàÎèÑ Î∂ÑÏÑù
    const attrCounts = {
        imageIndex: {},
        panelIndex: {},
        soundIndex: {},
        colorIndex: {}
    };
    sequence.forEach(s => {
        attrCounts.imageIndex[s.imageIndex] = (attrCounts.imageIndex[s.imageIndex] || 0) + 1;
        attrCounts.panelIndex[s.panelIndex] = (attrCounts.panelIndex[s.panelIndex] || 0) + 1;
        attrCounts.soundIndex[s.soundIndex] = (attrCounts.soundIndex[s.soundIndex] || 0) + 1;
        attrCounts.colorIndex[s.colorIndex] = (attrCounts.colorIndex[s.colorIndex] || 0) + 1;
    });

    console.log("%c[ÏãúÌÄÄÏä§ ÏÉùÏÑ±] ÏÜçÏÑ±Í∞í ÎπàÎèÑ Î∂ÑÏÑù:", "color: purple");
    for (const [attr, counts] of Object.entries(attrCounts)) {
        const frequent = Object.entries(counts).filter(([_, count]) => count >= 4);
        console.log(`  ${attr}: `, frequent.length > 0 
            ? frequent.map(([val, count]) => `${val}=${count}Ìöå`).join(", ")
            : "4Ìöå Ïù¥ÏÉÅ Î∞òÎ≥µÎêú Í∞í ÏóÜÏùå");
    }

    const patternAnalysisResult = analyzeAllPatterns(sequence);
    console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] ÏµúÏ¢Ö Î∂ÑÏÑù Í≤∞Í≥º (Ï†ÑÏ≤¥):", patternAnalysisResult.overallCounts);
    console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] ÏµúÏ¢Ö Î∂ÑÏÑù Í≤∞Í≥º (Ïú†ÌòïÎ≥Ñ):", patternAnalysisResult.typeCounts);
    console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] Ï¥ù Ìå®ÌÑ¥ Î∞úÏÉù ÌöüÏàò: " + patternAnalysisResult.totalPatterns);

    const { patternCounts } = analyzePatterns(sequence);
    console.log("%cÌå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥º: A-B-A: %d, A-B-A-B: %d", "color: red", patternCounts["A-B-A"], patternCounts["A-B-A-B"]);

    return sequence;
}









// N+1 ÎØ∏Î¶¨Î≥¥Í∏∞ Ìï®Ïàò (ÏïàÏ†ïÏÑ± ÌôïÎ≥¥)
function generateNextStimulusPreview(absoluteIndex, sequence, allTargets) {
    const nBackIndex = absoluteIndex - gameState.nBackLevel;
    const targetsAtPos = allTargets.filter(t => t.pos === absoluteIndex - gameState.nBackLevel);
    const recentLimit = gameState.nBackLevel * 2;

    let isSceneTarget = targetsAtPos.some(t => t.type === 'scene');
    let isLocationTarget = targetsAtPos.some(t => t.type === 'location');
    let isSoundTarget = targetsAtPos.some(t => t.type === 'sound');
    let isColorTarget = targetsAtPos.some(t => t.type === 'color');

    const imageIndex = isSceneTarget ? sequence[nBackIndex].imageIndex : selectIndexAvoidingRecent(gameState.recentSceneIndices, imageTextures.length, recentLimit);
    const panelIndex = isLocationTarget ? sequence[nBackIndex].panelIndex : selectIndexAvoidingRecent(gameState.recentLocationIndices, panels.length, recentLimit);
    const soundIndex = isSoundTarget ? sequence[nBackIndex].soundIndex : selectIndexAvoidingRecent(gameState.recentSoundIndices, gameState.pianoTones.length, recentLimit);
    const colorIndex = isColorTarget ? sequence[nBackIndex].colorIndex : selectIndexAvoidingRecent(gameState.recentColorIndices, distinctColors.length, recentLimit);

    return { imageIndex, panelIndex, soundIndex, colorIndex };
}
























// ÌÉÄÍ≤ü ÏúÑÏπòÎ•º ÏÑ†Ï†ïÌïòÎäî Ìï®Ïàò (Ìå®ÌÑ¥ Î∞©ÏßÄ Î∞è ÏïàÏ†ïÏÑ± Í∞ïÌôî)
function selectTargetPositions(intervalStimuli, targetCount, minInterval) {
    console.log(`selectTargetPositions() - ÌÉÄÍ≤ü ÏúÑÏπò ÏÑ†Ï†ï ÏãúÏûë: Íµ¨Í∞Ñ ÏûêÍ∑π Ïàò=${intervalStimuli}, ÌÉÄÍ≤ü Ïàò=${targetCount}, ÏµúÏÜå Í∞ÑÍ≤©=${minInterval}`);
    const positions = [];
    let attempts = 0;
    const maxAttempts = 200;

    while (attempts < maxAttempts) {
        const availablePositions = Array.from({ length: intervalStimuli }, (_, i) => i);
        shuffleArray(availablePositions);

        while (positions.length < targetCount && availablePositions.length > 0) {
            const pos = availablePositions.pop();
            if (positions.every(p => Math.abs(p - pos) >= minInterval)) {
                positions.push(pos);
            }
        }

        if (positions.length < targetCount) {
            console.warn(`selectTargetPositions() - Î™®Îì† ÌÉÄÍ≤ü Î∞∞Ïπò Î∂àÍ∞Ä: Î∞∞ÏπòÎêú ÌÉÄÍ≤ü ${positions.length}/${targetCount}`);
            return positions.sort((a, b) => a - b);
        }

        positions.sort((a, b) => a - b);
        const diffs = positions.slice(1).map((p, i) => p - positions[i]);
        const isEqualInterval = diffs.length > 1 && diffs.every(d => d === diffs[0]);
        const isConsecutive = diffs.some(d => d === 1);
        const isCyclic = checkCyclicPattern(positions);

        console.log(`selectTargetPositions() - ÏãúÎèÑ ${attempts + 1}: ÏúÑÏπò=${positions}, Í∞ÑÍ≤©=${diffs}`);

        if (!isConsecutive && !isCyclic && (!isEqualInterval || diffs.length <= 2)) {
            console.log(`selectTargetPositions() - ÏÑ±Í≥µ: ÏúÑÏπò=${positions}, ÏãúÎèÑ ÌöüÏàò=${attempts}`);
            return positions;
        }

        positions.length = 0; // Ïã§Ìå® Ïãú Ï¥àÍ∏∞Ìôî
        attempts++;
    }

    console.error(`selectTargetPositions() - ${maxAttempts}Î≤à ÏãúÎèÑ ÌõÑ Ïã§Ìå®`);
    return [];
}


// Ï£ºÍ∏∞Ï†Å Ìå®ÌÑ¥ Í∞êÏßÄ Ìï®Ïàò
function checkCyclicPattern(positions) {
    if (positions.length < 4) return false;
    for (let i = 0; i < positions.length - 3; i++) {
        const seq = positions.slice(i, i + 4);
        const diffs = seq.slice(1).map((p, idx) => p - seq[idx]);
        if (diffs[0] === diffs[2] && diffs[0] !== diffs[1]) { // A-B-C-A Ìå®ÌÑ¥ Ï≤¥ÌÅ¨
            console.log(`checkCyclicPattern() - Cyclic pattern found: ${seq}, Diffs: ${diffs}`);
            return true;
        }
    }
    return false;
}


function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


function analyzePatterns(sequence) {
    const patternCounts = {
        "A-B-A": 0,
        "A-B-A-B": 0
    };

    const targetTypeSequence = sequence.map(s => s.targetType);

    // A-B-A Ìå®ÌÑ¥ Î∂ÑÏÑù
    for (let i = 2; i < targetTypeSequence.length; i++) {
        const last3 = targetTypeSequence.slice(i - 2, i + 1);
        if (last3[0] === last3[2] && last3[0] !== last3[1] && last3[0] !== "non-target" && last3[2] !== "non-target") {
            patternCounts["A-B-A"]++;
        }
    }

    // A-B-A-B Ìå®ÌÑ¥ Î∂ÑÏÑù
    for (let i = 3; i < targetTypeSequence.length; i++) {
        const last4 = targetTypeSequence.slice(i - 3, i + 1);
        if (last4[0] === last4[2] && last4[1] === last4[3] && last4[0] !== last4[1] && last4[0] !== "non-target" && last4[2] !== "non-target") {
            patternCounts["A-B-A-B"]++;
        }
    }

    // ÎîîÎ≤ÑÍπÖ: Ìå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Îπ®Í∞ÑÏÉâÏúºÎ°ú Ï∂úÎ†•
    console.log("%cÌå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥º: A-B-A: %d, A-B-A-B: %d", "color: red", patternCounts["A-B-A"], patternCounts["A-B-A-B"]);
    console.log(`analyzePatterns() - Ìå®ÌÑ¥ Î∂ÑÏÑù ÏôÑÎ£å:`, patternCounts);
    return { patternCounts };
}





// Ìå®ÌÑ¥ Î∂ÑÏÑù Ìï®Ïàò: ÏãúÌÄÄÏä§Ïùò Ìå®ÌÑ¥ Ïú†ÌòïÍ≥º ÌöüÏàòÎ•º Í≥ÑÏÇ∞
// A-B-A: ÎèôÏùºÌïú ÌÉÄÍ≤ü Ïú†ÌòïÏù¥ Ìïú ÏûêÍ∑πÏùÑ ÏÇ¨Ïù¥Ïóê ÎëêÍ≥† Î∞òÎ≥µÎêòÎäî Í≤ΩÏö∞
// A-B-A-B: Îëê ÏåçÏùò ÌÉÄÍ≤ü Ïú†ÌòïÏù¥ ÍµêÏ∞® Î∞òÎ≥µÎêòÎäî Í≤ΩÏö∞
// Ï∂îÍ∞Ä: ÏÜçÏÑ±Î≥Ñ ÎπàÎèÑ Î∞è ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Î∂ÑÏÑù
function analyzeAllPatterns(sequence) {
    // Ï¥àÍ∏∞Ìôî: Ï†ÑÏ≤¥ Î∞è Í∞Å ÏûêÍ∑π Ïú†ÌòïÎ≥Ñ Ìå®ÌÑ¥ Ïπ¥Ïö¥Ìä∏ Í∞ùÏ≤¥ ÏÉùÏÑ±
    const overallCounts = { "A-A": 0, "A-B-A": 0, "A-B-A-B": 0 };
    const types = ['scene', 'location', 'sound', 'color'];
    const typeCounts = {
        scene: { "A-A": 0, "A-B-A": 0, "A-B-A-B": 0 },
        location: { "A-A": 0, "A-B-A": 0, "A-B-A-B": 0 },
        sound: { "A-A": 0, "A-B-A": 0, "A-B-A-B": 0 },
        color: { "A-A": 0, "A-B-A": 0, "A-B-A-B": 0 }
    };

    // ÏÜçÏÑ±Î≥Ñ ÎπàÎèÑ Î∞è ÏúÑÏπò Ï∂îÏ†Å Í∞ùÏ≤¥
    const attributeCounts = {
        imageIndex: {},
        panelIndex: {},
        soundIndex: {},
        colorIndex: {}
    };

    // ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Ïπ¥Ïö¥Ìä∏ Í∞ùÏ≤¥
    const distributionPatterns = {
        "DoubleTarget": 0, // T-T-N: Ïó∞ÏÜç ÌÉÄÍ≤ü ÌõÑ ÎÖºÌÉÄÍ≤ü
        "LateDouble": 0,   // N-N-T-T: ÎÖºÌÉÄÍ≤ü Ïó∞ÏÜç ÌõÑ ÌÉÄÍ≤ü Ïåç
        "Alternating": 0,  // N-T-N-T: ÎÖºÌÉÄÍ≤üÍ≥º ÌÉÄÍ≤ü ÍµêÏ∞®
        "TripleNonTarget": 0 // N-N-N-T: ÎÖºÌÉÄÍ≤ü 3Í∞ú ÌõÑ ÌÉÄÍ≤ü
    };
    const patternPositions = { // Ìå®ÌÑ¥ Î∞úÏÉù ÏúÑÏπò Í∏∞Î°ù
        "DoubleTarget": [],
        "LateDouble": [],
        "Alternating": [],
        "TripleNonTarget": []
    };

    // Helper: ÌÉÄÍ≤ü Ïú†Ìö®ÏÑ± ÌåêÎã®
    function isValidTarget(targetType) {
        return targetType !== "non-target" && targetType !== "initial";
    }

    // ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Ï†êÍ≤Ä
    if (!sequence || sequence.length === 0) {
        console.log("%c[Î∂ÑÏÑù][Ïò§Î•ò] ÏãúÌÄÄÏä§Í∞Ä ÎπÑÏñ¥ÏûàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå", "color: red");
        return { overallCounts, typeCounts, totalPatterns: 0 };
    }
    console.log(`%c[Î∂ÑÏÑù][ÏûÖÎ†•] ÏãúÌÄÄÏä§ Í∏∏Ïù¥: ${sequence.length}, ÎÇ¥Ïö©:`, "color: blue", sequence.map(s => ({
        targetType: s.targetType || "non-target",
        imageIndex: s.imageIndex,
        panelIndex: s.panelIndex,
        soundIndex: s.soundIndex,
        colorIndex: s.colorIndex
    })));

    // Ï†ÑÏ≤¥ ÏãúÌÄÄÏä§Ïóê ÎåÄÌï¥ Î∂ÑÏÑù
    const targetTypeSequence = sequence.map(s => s.targetType || "non-target");
    const len = targetTypeSequence.length;

    // A-A Ìå®ÌÑ¥ Î∂ÑÏÑù
    for (let i = 1; i < len; i++) {
        const prev = targetTypeSequence[i - 1];
        const curr = targetTypeSequence[i];
        if (isValidTarget(prev) && isValidTarget(curr) && prev === curr) {
            overallCounts["A-A"]++;
            if (types.includes(curr)) typeCounts[curr]["A-A"]++;
        }
    }

    // A-B-A Ìå®ÌÑ¥ Î∂ÑÏÑù
    for (let i = 2; i < len; i++) {
        const first = targetTypeSequence[i - 2];
        const middle = targetTypeSequence[i - 1];
        const last = targetTypeSequence[i];
        if (isValidTarget(first) && isValidTarget(middle) && isValidTarget(last) &&
            first === last && first !== middle) {
            overallCounts["A-B-A"]++;
            if (types.includes(first)) typeCounts[first]["A-B-A"]++;
        }
    }

    // A-B-A-B Ìå®ÌÑ¥ Î∂ÑÏÑù
    for (let i = 3; i < len; i++) {
        const t0 = targetTypeSequence[i - 3];
        const t1 = targetTypeSequence[i - 2];
        const t2 = targetTypeSequence[i - 1];
        const t3 = targetTypeSequence[i];
        if (isValidTarget(t0) && isValidTarget(t1) && isValidTarget(t2) && isValidTarget(t3) &&
            t0 === t2 && t1 === t3 && t0 !== t1) {
            overallCounts["A-B-A-B"]++;
            if (types.includes(t0)) typeCounts[t0]["A-B-A-B"]++;
        }
    }

    // ÏÜçÏÑ±Î≥Ñ ÎπàÎèÑ Í≥ÑÏÇ∞
    sequence.forEach((stimulus, index) => {
        ['imageIndex', 'panelIndex', 'soundIndex', 'colorIndex'].forEach(attr => {
            const value = stimulus[attr] !== undefined ? stimulus[attr] : -1;
            if (!attributeCounts[attr][value]) {
                attributeCounts[attr][value] = { count: 0, positions: [] };
            }
            attributeCounts[attr][value].count++;
            attributeCounts[attr][value].positions.push(index);
        });
    });

    // ÏÜçÏÑ±Î≥Ñ Ï§ëÍ∞Ñ Í≤∞Í≥º ÎîîÎ≤ÑÍπÖ
    console.log("%c[Î∂ÑÏÑù][Ï§ëÍ∞Ñ] ÏÜçÏÑ±Î≥Ñ ÎπàÎèÑ Í≥ÑÏÇ∞ Í≤∞Í≥º:", "color: purple", attributeCounts);

    // ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Î∂ÑÏÑù
    if (len < 4) {
        console.log("%c[Î∂ÑÏÑù][Í≤ΩÍ≥†] ÏãúÌÄÄÏä§ Í∏∏Ïù¥Í∞Ä 4 ÎØ∏ÎßåÏù¥Îùº ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Î∂ÑÏÑù Î∂àÍ∞Ä", "color: orange");
    } else {
        for (let i = 3; i < len; i++) {
            const t0 = targetTypeSequence[i - 3];
            const t1 = targetTypeSequence[i - 2];
            const t2 = targetTypeSequence[i - 1];
            const t3 = targetTypeSequence[i];

            if (!isValidTarget(t0) && isValidTarget(t1) && !isValidTarget(t2) && isValidTarget(t3)) {
                distributionPatterns["Alternating"]++;
                patternPositions["Alternating"].push(i - 3);
                console.log(`%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] Alternating Î∞úÍ≤¨: ÏúÑÏπò ${i - 3}, ÏãúÌÄÄÏä§ [${t0},${t1},${t2},${t3}]`, "color: green");
                continue;
            }

            if (!isValidTarget(t0) && !isValidTarget(t1) && isValidTarget(t2) && isValidTarget(t3)) {
                distributionPatterns["LateDouble"]++;
                patternPositions["LateDouble"].push(i - 3);
                console.log(`%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] LateDouble Î∞úÍ≤¨: ÏúÑÏπò ${i - 3}, ÏãúÌÄÄÏä§ [${t0},${t1},${t2},${t3}]`, "color: green");
                continue;
            }

            if (!isValidTarget(t0) && !isValidTarget(t1) && !isValidTarget(t2) && isValidTarget(t3)) {
                distributionPatterns["TripleNonTarget"]++;
                patternPositions["TripleNonTarget"].push(i - 3);
                console.log(`%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] TripleNonTarget Î∞úÍ≤¨: ÏúÑÏπò ${i - 3}, ÏãúÌÄÄÏä§ [${t0},${t1},${t2},${t3}]`, "color: green");
                continue;
            }

            if (i - 2 >= 0) {
                const prev2 = targetTypeSequence[i - 2];
                const prev1 = targetTypeSequence[i - 1];
                const curr = targetTypeSequence[i];
                if (isValidTarget(prev2) && isValidTarget(prev1) && !isValidTarget(curr)) {
                    distributionPatterns["DoubleTarget"]++;
                    patternPositions["DoubleTarget"].push(i - 2);
                    console.log(`%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] DoubleTarget Î∞úÍ≤¨: ÏúÑÏπò ${i - 2}, ÏãúÌÄÄÏä§ [${prev2},${prev1},${curr}]`, "color: green");
                }
            }
        }
    }

    // Ï¥ùÌï© Í≥ÑÏÇ∞
    const totalPatterns = overallCounts["A-A"] + overallCounts["A-B-A"] + overallCounts["A-B-A-B"];

    // Í∏∞Ï°¥ Î°úÍ∑∏ Ï∂úÎ†•
    console.log("%c[Î∂ÑÏÑù] Ï†ÑÏ≤¥ Ìå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥º - A-A: " + overallCounts["A-A"] +
        ", A-B-A: " + overallCounts["A-B-A"] +
        ", A-B-A-B: " + overallCounts["A-B-A-B"] +
        " (Ï¥ùÌï©: " + totalPatterns + ")", "color: blue");
    types.forEach(type => {
        const subTotal = typeCounts[type]["A-A"] + typeCounts[type]["A-B-A"] + typeCounts[type]["A-B-A-B"];
        console.log("%c[Î∂ÑÏÑù] " + type + " Ìå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥º - A-A: " + typeCounts[type]["A-A"] +
            ", A-B-A: " + typeCounts[type]["A-B-A"] +
            ", A-B-A-B: " + typeCounts[type]["A-B-A-B"] +
            " (Ï¥ùÌï©: " + subTotal + ")", "color: green");
    });

    // ÏàòÏ†ï: ÏÜçÏÑ±Î≥Ñ ÎπàÎèÑ Î°úÍ∑∏ Í∞úÏÑ† - Ï§ëÍ∞Ñ Ï†êÍ≤Ä Î∞è Îã®ÏàúÌôîÎêú Ï∂úÎ†•
    ['imageIndex', 'panelIndex', 'soundIndex', 'colorIndex'].forEach(attr => {
        const allValues = Object.entries(attributeCounts[attr])
            .map(([value, data]) => ({
                value,
                count: data.count,
                positions: data.positions,
                avgInterval: data.positions.length > 1
                    ? (data.positions[data.positions.length - 1] - data.positions[0]) / (data.positions.length - 1)
                    : 0
            }))
            .sort((a, b) => b.count - a.count); // ÎπàÎèÑ ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨

        // Ï£ºÏÑù: Ï§ëÍ∞Ñ Ï†êÍ≤Ä Î°úÍ∑∏ Ï∂îÍ∞Ä
        console.log(`%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] ${attr} ÎπàÎèÑ Í∞í Í≥ÑÏÇ∞ ÏôÑÎ£å - Ìï≠Î™© Ïàò: ${allValues.length}`, "color: purple", allValues);

        // Ï£ºÏÑù: Ï∂úÎ†• Îã®ÏàúÌôî - Ïä§ÌÉÄÏùºÎßÅ ÏµúÏÜåÌôî, Ìïú Î≤àÏóê Ï∂úÎ†•
        console.log(`[Î∂ÑÏÑù][Ìå®ÌÑ¥] ${attr} Î™®Îì† ÎπàÎèÑ Í∞í:`);
        console.log(allValues.map(v => 
            `  Í∞í=${v.value}, ÌöüÏàò=${v.count}${v.count >= 4 ? ' (ÎπàÎèÑ ÎÜíÏùå)' : ''}, ÏúÑÏπò=[${v.positions.join(", ")}], ÌèâÍ∑† Í∞ÑÍ≤©=${v.avgInterval.toFixed(2)}`
        ).join("\n"));
    });

    // ÏàòÏ†ï: ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Î°úÍ∑∏ Í∞úÏÑ† - Ï§ëÍ∞Ñ Ï†êÍ≤Ä Î∞è Îã®ÏàúÌôîÎêú Ï∂úÎ†•
    // Ï£ºÏÑù: Ï§ëÍ∞Ñ Ï†êÍ≤Ä Î°úÍ∑∏ Ï∂îÍ∞Ä
    console.log("%c[Î∂ÑÏÑù][Ìå®ÌÑ¥] ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Í≥ÑÏÇ∞ ÏôÑÎ£å:", "color: orange", { distributionPatterns, patternPositions });

    // Ï£ºÏÑù: Ï∂úÎ†• Îã®ÏàúÌôî - Ïä§ÌÉÄÏùºÎßÅ ÏµúÏÜåÌôî, Ìïú Î≤àÏóê Ï∂úÎ†•
    console.log(`[Î∂ÑÏÑù][Ìå®ÌÑ¥] ÌÉÄÍ≤ü Î∂ÑÌè¨ Ìå®ÌÑ¥ Î∂ÑÏÑù Í≤∞Í≥º:`);
    console.log(Object.entries(distributionPatterns).map(([pattern, count]) => 
        `  ${pattern}: ${count}Ìöå (ÏúÑÏπò: ${patternPositions[pattern].join(", ") || "ÏóÜÏùå"})`
    ).join("\n"));

    return { overallCounts, typeCounts, totalPatterns };
}











function findProblematicPositions(sequence) {
    const problematicPositions = [];
    const targetTypeSequence = sequence.map(s => s.targetType);

    // A-B-A Ìå®ÌÑ¥Ïóê ÎåÄÌïú Î¨∏Ï†ú ÏúÑÏπò ÌÉêÏßÄ (Ï§ëÍ∞Ñ ÏúÑÏπò)
    for (let i = 2; i < targetTypeSequence.length; i++) {
        const first = targetTypeSequence[i - 2];
        const middle = targetTypeSequence[i - 1];
        const last = targetTypeSequence[i];
        if (first === last && first !== middle && first !== "non-target" && first !== "initial") {
            problematicPositions.push(i - 1);
            console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] A-B-A Ìå®ÌÑ¥ Î¨∏Ï†ú ÏúÑÏπò Î∞úÍ≤¨: Ïù∏Îç±Ïä§ " + (i - 1));
        }
    }

    // A-B-A-B Ìå®ÌÑ¥Ïóê ÎåÄÌïú Î¨∏Ï†ú ÏúÑÏπò ÌÉêÏßÄ (Îëê Î≤àÏß∏ Í∑∏Î£πÏùò Ï≤´ Î≤àÏß∏ ÏúÑÏπò)
    for (let i = 3; i < targetTypeSequence.length; i++) {
        const t0 = targetTypeSequence[i - 3];
        const t1 = targetTypeSequence[i - 2];
        const t2 = targetTypeSequence[i - 1];
        const t3 = targetTypeSequence[i];
        if (t0 === t2 && t1 === t3 && t0 !== t1 && t0 !== "non-target" && t0 !== "initial") {
            problematicPositions.push(i - 2);
            console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] A-B-A-B Ìå®ÌÑ¥ Î¨∏Ï†ú ÏúÑÏπò Î∞úÍ≤¨: Ïù∏Îç±Ïä§ " + (i - 2));
        }
    }

    // Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ Î∞òÌôò
    const uniquePositions = [...new Set(problematicPositions)];
    console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] ÏµúÏ¢Ö Î¨∏Ï†úÏ†ê ÏúÑÏπò Î™©Î°ù: ", uniquePositions);
    return uniquePositions;
}






function adjustTargetPositions(sequence, problematicPositions) {
    // ÌÉÄÍ≤ü Ïú†Ìòï ÌõÑÎ≥¥ (ÌÉÄÍ≤ü ÏÉùÏÑ± Î°úÏßÅÍ≥º ÏùºÏπòÌï¥Ïïº Ìï®)
    const targetTypes = ['scene', 'location', 'sound', 'color'];
    problematicPositions.forEach(pos => {
        const currentType = sequence[pos].targetType;
        // ÌòÑÏû¨ ÌÉÄÍ≤üÍ≥º Îã§Î•∏ ÌõÑÎ≥¥ Ï§ëÏóêÏÑú Î¨¥ÏûëÏúÑ ÏÑ†ÌÉù
        const newCandidates = targetTypes.filter(t => t !== currentType);
        const newTargetType = newCandidates[Math.floor(Math.random() * newCandidates.length)];
        // Î≥ÄÍ≤Ω Ï†Ñ/ÌõÑ Ï†ïÎ≥¥Î•º Í∏∞Î°ù (ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏Ïóê "Î∂ÑÏÑù"Í≥º "Ìå®ÌÑ¥" Ìè¨Ìï®)
        console.log("[Î∂ÑÏÑù][Ìå®ÌÑ¥] adjustTargetPositions() - ÏúÑÏπò " + pos +
            " Î≥ÄÍ≤Ω: " + currentType + " -> " + newTargetType);
        sequence[pos].targetType = newTargetType;
        // Í∞Å ÏûêÍ∑π Ïú†ÌòïÏóê Îî∞Î•∏ ÌîåÎûòÍ∑∏ Ïû¨ÏÑ§Ï†ï (ÌïÑÏöîÏãú Í∏∞Ï°¥ Î°úÏßÅÍ≥º ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨)
        sequence[pos].isSceneTarget = newTargetType === 'scene';
        sequence[pos].isLocationTarget = newTargetType === 'location';
        sequence[pos].isSoundTarget = newTargetType === 'sound';
        sequence[pos].isColorTarget = newTargetType === 'color';
    });
}







function updateGameCounters() {
    console.log("updateGameCounters() - Í≤åÏûÑ Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë: totalGamesToday=", gameState.totalGamesToday, "consecutiveGames=", gameState.consecutiveGames);
    document.getElementById('totalGamesTodayCountValue').textContent = gameState.totalGamesToday;
    document.getElementById('consecutiveGamesCount').textContent = gameState.consecutiveGames;
    localStorage.setItem('totalGamesToday', gameState.totalGamesToday);
    localStorage.setItem('consecutiveGames', gameState.consecutiveGames);
    console.log("updateGameCounters() - UI Î∞è Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å, timestamp=", Date.now());
}






function endBlock() {
    console.log("endBlock() - Î∏îÎ°ù Ï¢ÖÎ£å ÏãúÏûë: currentBlock=", gameState.currentBlock, "maxBlocks=", gameState.maxBlocks, "timestamp=", Date.now());
    gameState.isPlaying = false;
    cancelAllTimers();
    clearAllStimuli();
    stopSound();

    console.log("endBlock() - ÌÉÄÍ≤ü Î∞è ÏóêÎü¨ ÌÜµÍ≥Ñ:", {
        sceneTargets: gameState.sceneTargets,
        sceneErrors: gameState.sceneErrors,
        locationTargets: gameState.locationTargets,
        locationErrors: gameState.locationErrors,
        soundTargets: gameState.soundTargets,
        soundErrors: gameState.soundErrors,
        colorTargets: gameState.colorTargets,
        colorErrors: gameState.colorErrors,
        nearMissResponses: gameState.nearMissResponses,
        nearMissHistoryLength: nearMissHistory.length
    });

    const totalTargets = gameState.sceneTargets + gameState.locationTargets + gameState.soundTargets + gameState.colorTargets;
    const totalErrors = gameState.sceneErrors + gameState.locationErrors + gameState.soundErrors + gameState.colorErrors;
    const totalAccuracy = totalTargets > 0 ? (1 - totalErrors / totalTargets) * 100 : 100;
    gameState.accuracyHistory.push(totalAccuracy);

    console.log("endBlock() - Ï†ïÌôïÎèÑ Í≥ÑÏÇ∞: totalTargets=", totalTargets, "totalErrors=", totalErrors, "totalAccuracy=", totalAccuracy.toFixed(2) + "%");

    if (!gameState.isLevelLocked && gameState.currentBlock >= gameState.maxBlocks - 1) {
        const recentAccuracy = gameState.accuracyHistory.slice(-3).reduce((a, b) => a + b, 0) / Math.min(gameState.accuracyHistory.length, 3);
        console.log("endBlock() - ÏµúÍ∑º 3Í∞ú Î∏îÎ°ù ÌèâÍ∑† Ï†ïÌôïÎèÑ:", recentAccuracy.toFixed(2) + "%");

        let levelChangeText = '';
        if (recentAccuracy > 90 && gameState.nBackLevel < 9) {
            gameState.nBackLevel++;
            levelChangeText = `Î†àÎ≤® ÏóÖ! ${gameState.nBackLevel}-BackÏúºÎ°ú ÏÉÅÏäπ`;
            console.log("endBlock() - Î†àÎ≤® ÏóÖ Ï°∞Í±¥ Ï∂©Ï°±, ÏÉà Î†àÎ≤®:", gameState.nBackLevel);
        } else if (recentAccuracy < 70 && gameState.nBackLevel > 1) {
            gameState.nBackLevel--;
            levelChangeText = `Î†àÎ≤® Îã§Ïö¥... ${gameState.nBackLevel}-BackÏúºÎ°ú ÌïòÎùΩ`;
            console.log("endBlock() - Î†àÎ≤® Îã§Ïö¥ Ï°∞Í±¥ Ï∂©Ï°±, ÏÉà Î†àÎ≤®:", gameState.nBackLevel);
        } else {
            levelChangeText = `${gameState.nBackLevel}-Back Ïú†ÏßÄ`;
            console.log("endBlock() - Î†àÎ≤® Î≥ÄÍ≤Ω Ï°∞Í±¥ ÎØ∏Ï∂©Ï°±, ÌòÑÏû¨ Î†àÎ≤® Ïú†ÏßÄ:", gameState.nBackLevel);
        }
        document.getElementById('levelChange').textContent = levelChangeText;
        localStorage.setItem('nBackLevel', gameState.nBackLevel);
    }

    document.getElementById('resultNLevel').textContent = gameState.nBackLevel;
    document.getElementById('sceneErrors').textContent = gameState.sceneErrors;
    document.getElementById('locationErrors').textContent = gameState.locationErrors;
    document.getElementById('soundErrors').textContent = gameState.soundErrors;
    document.getElementById('colorErrors').textContent = gameState.colorErrors;

    const nearMissPercentage = nearMissHistory.length > 0 ? (gameState.nearMissResponses / nearMissHistory.length * 100).toFixed(2) : "0.00";
    document.getElementById('nearMissStats').textContent = `ÎãàÏñºÎØ∏Ïä§ Î∞òÏùë: ${gameState.nearMissResponses}/${nearMissHistory.length} (${nearMissPercentage}%)`;
    console.log("endBlock() - ÎãàÏñºÎØ∏Ïä§ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏:", {
        responses: gameState.nearMissResponses,
        total: nearMissHistory.length,
        percentage: nearMissPercentage + "%"
    });

    const resultScreen = document.getElementById('resultScreen');
    const resultBackgroundImage = document.getElementById('resultBackgroundImage');
    if (gameState.resultImageUrl) {
        resultBackgroundImage.style.backgroundImage = `url(${gameState.resultImageUrl})`;
        resultBackgroundImage.style.backgroundSize = 'cover';
        resultBackgroundImage.style.backgroundPosition = 'center';
        console.log("endBlock() - Í≤∞Í≥º Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ ÏÑ§Ï†ïÎê®:", gameState.resultImageUrl);
    } else {
        resultBackgroundImage.style.backgroundImage = 'none';
        console.log("endBlock() - Í≤∞Í≥º Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ ÏóÜÏùå");
    }

    if (resultScreen.style.display !== 'flex') {
        resultScreen.style.display = 'flex';
        console.log("endBlock() - Í≤∞Í≥º ÌôîÎ©¥ ÌëúÏãúÎê®");
    }

    // Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    gameState.totalGamesToday++;
    gameState.consecutiveGames++;
    localStorage.setItem('lastGameTimestamp', Date.now().toString());
    updateGameCounters(); // ÌÜµÌï©Îêú Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò Ìò∏Ï∂ú
    console.log("endBlock() - Í≤åÏûÑ Ï¢ÖÎ£å ÌõÑ Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å: totalGamesToday=", gameState.totalGamesToday, "consecutiveGames=", gameState.consecutiveGames);

    gameState.currentBlock++;
    if (gameState.currentBlock >= gameState.maxBlocks) {
        gameState.currentBlock = 0;
        console.log("endBlock() - ÏµúÎåÄ Î∏îÎ°ù ÎèÑÎã¨, currentBlock Ï¥àÍ∏∞Ìôî:", gameState.currentBlock);
    }

    resetGameStateForNewBlock();
    console.log("endBlock() - Î∏îÎ°ù Ï¢ÖÎ£å ÏôÑÎ£å, ÏÉÅÌÉú Î¶¨ÏÖã ÌõÑ Ï§ÄÎπÑÎê®, timestamp=", Date.now());
}





function showTitleScreen() {
    console.log("showTitleScreen() - ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú ÏãúÏûë, timestamp=", Date.now());
    cancelAllTimers();
    clearAllStimuli();
    stopSound();
    gameState.isPlaying = false;
    gameState.isPaused = false;
    gameState.consecutiveGames = 0; // ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÎ©¥ Ïó∞ÏÜç Í≤åÏûÑ ÌöüÏàò Î¶¨ÏÖã
    updateGameCounters(); // Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    console.log("showTitleScreen() - Ïó∞ÏÜç Í≤åÏûÑ ÌöüÏàò Î¶¨ÏÖãÎê®: consecutiveGames=", gameState.consecutiveGames);

    const titleScreen = document.getElementById('titleScreen');
    const gameScreen = document.getElementById('gameScreen');
    const resultScreen = document.getElementById('resultScreen');
    const pauseScreen = document.getElementById('pauseScreen');
    const settingsPanel = document.getElementById('settingsPanel');

    if (titleScreen && gameScreen && resultScreen && pauseScreen && settingsPanel) {
        titleScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        resultScreen.style.display = 'none';
        pauseScreen.style.display = 'none';
        settingsPanel.style.display = 'none';
        console.log("showTitleScreen() - Î™®Îì† ÌôîÎ©¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Îê®");
    } else {
        console.error("showTitleScreen() - ÏùºÎ∂Ä ÌôîÎ©¥ ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå", {
            titleScreen: !!titleScreen,
            gameScreen: !!gameScreen,
            resultScreen: !!resultScreen,
            pauseScreen: !!pauseScreen,
            settingsPanel: !!settingsPanel
        });
    }

    document.getElementById('nBackLevel').textContent = gameState.nBackLevel;
    document.getElementById('customLevel').value = gameState.nBackLevel;
    console.log("showTitleScreen() - ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú ÏôÑÎ£å: nBackLevel=", gameState.nBackLevel, "timestamp=", Date.now());
}

function resetStimulusCounter() {
    const stimulusCounter = document.getElementById('stimulus-counter');
    stimulusCounter.textContent = `Stimulus: ${gameState.currentStimulus} / ${gameState.stimuliPerBlock}`;
}

function updateStimulusCounter() {
    const stimulusCounter = document.getElementById('stimulus-counter');
    stimulusCounter.textContent = `Stimulus: ${gameState.currentStimulus + 1} / ${gameState.stimuliPerBlock}`;
}

function setBackgroundImageToResultScreen() {
    const resultBackgroundImage = document.getElementById('resultBackgroundImage');
    if (gameState.resultImageUrl) {
        resultBackgroundImage.style.backgroundImage = `url(${gameState.resultImageUrl})`;
    } else {
        resultBackgroundImage.style.backgroundImage = '';
    }
}

document.getElementById('pressSpaceResult').addEventListener('click', () => {
    if (!gameState.isPlaying) {
        const resultScreen = document.getElementById('resultScreen');
        if (resultScreen) {
            resultScreen.style.display = 'none';
            console.log("pressSpaceResult - resultScreen hidden successfully");
        } else {
            console.error("pressSpaceResult - resultScreen element not found in DOM");
        }
        startBlock();
        console.log("pressSpaceResult - Clicked 'Í≤åÏûÑ Í≥ÑÏÜç', starting new block", {
            timestamp: Date.now()
        });
    }
});
document.getElementById('pressSpace').addEventListener('click', () => {
    if (!gameState.isPlaying) {
        startBlock();
    }
});

document.addEventListener('keydown', handleKeyPress);

sceneIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("scene") && !gameState.sceneTargetProcessed && gameState.canRespond) {
        handleSceneResponse();
    }
});

locationIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("location") && !gameState.locationTargetProcessed && gameState.canRespond) {
        handleLocationResponse();
    }
});

soundIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("sound") && !gameState.soundTargetProcessed && gameState.canRespond) {
        handleSoundResponse();
    }
});

colorIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("color") && !gameState.colorTargetProcessed && gameState.canRespond) {
        handleColorResponse();
    }
});

// Í∏∞Ï°¥ click Ïù¥Î≤§Ìä∏ Ïú†ÏßÄ
sceneIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("scene") && !gameState.sceneTargetProcessed && gameState.canRespondScene) {
        handleSceneResponse();
    }
});

locationIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("location") && !gameState.locationTargetProcessed && gameState.canRespondLocation) {
        handleLocationResponse();
    }
});

soundIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("sound") && !gameState.soundTargetProcessed && gameState.canRespondSound) {
        handleSoundResponse();
    }
});

colorIndicator.addEventListener('click', () => {
    if (gameState.isPlaying && gameState.stimulusTypes.includes("color") && !gameState.colorTargetProcessed && gameState.canRespondColor) {
        handleColorResponse();
    }
});

// touchstart Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
sceneIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ (Ï§å Îì±)
    if (gameState.isPlaying && gameState.stimulusTypes.includes("scene") && !gameState.sceneTargetProcessed && gameState.canRespondScene) {
        handleSceneResponse();
        console.log("touchstart - Scene touched, touches:", e.touches.length, "timestamp:", Date.now());
    }
});

locationIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gameState.isPlaying && gameState.stimulusTypes.includes("location") && !gameState.locationTargetProcessed && gameState.canRespondLocation) {
        handleLocationResponse();
        console.log("touchstart - Location touched, touches:", e.touches.length, "timestamp:", Date.now());
    }
});

soundIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gameState.isPlaying && gameState.stimulusTypes.includes("sound") && !gameState.soundTargetProcessed && gameState.canRespondSound) {
        handleSoundResponse();
        console.log("touchstart - Sound touched, touches:", e.touches.length, "timestamp:", Date.now());
    }
});

colorIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gameState.isPlaying && gameState.stimulusTypes.includes("color") && !gameState.colorTargetProcessed && gameState.canRespondColor) {
        handleColorResponse();
        console.log("touchstart - Color touched, touches:", e.touches.length, "timestamp:", Date.now());
    }
});

// ‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
document.getElementById('pauseBtn').addEventListener('click', pauseGame);

// ‚è∏Ô∏è Í≤åÏûÑ Ïû¨Í∞ú Î≤ÑÌäº Ïù¥Î≤§Ìä∏
document.getElementById('resumeGameBtn').addEventListener('click', resumeGame);

// ‚è∏Ô∏è Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
document.getElementById('mainMenuBtn').addEventListener('click', () => {
    console.log("mainMenuBtn clicked"); // ÌÅ¥Î¶≠ ÌôïÏù∏Ïö© Î°úÍ∑∏
    showTitleScreen();
});

document.getElementById('mainMenuResultBtn').addEventListener('click', () => {
    console.log("mainMenuResultBtn ÌÅ¥Î¶≠Îê® - Î©îÏù∏Î©îÎâ¥Î°ú Ïù¥Îèô ÏãúÏûë"); // ÎîîÎ≤ÑÍπÖ: ÌÅ¥Î¶≠ Í∞êÏßÄ
    showTitleScreen();
    console.log("mainMenuResultBtn - showTitleScreen Ìò∏Ï∂ú ÏôÑÎ£å"); // ÎîîÎ≤ÑÍπÖ: Ìò∏Ï∂ú ÌôïÏù∏
});



// üñºÔ∏è Ï†ÑÏ≤¥ÌôîÎ©¥ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

document.getElementById('setLevelBtn').addEventListener('click', () => {
    const customLevel = parseInt(document.getElementById('customLevel').value);
    if (customLevel >= 1 && customLevel <= 9) {
        gameState.nBackLevel = customLevel;
        document.getElementById('nBackLevel').textContent = gameState.nBackLevel;
        localStorage.setItem('nBackLevel', gameState.nBackLevel);
    }
});

document.getElementById('lockLevelBtn').addEventListener('click', () => {
    gameState.isLevelLocked = !gameState.isLevelLocked;
    const lockButton = document.getElementById('lockLevelBtn');
    lockButton.classList.toggle('locked', gameState.isLevelLocked);
    lockButton.textContent = gameState.isLevelLocked ? 'Ìï¥Ï†ú' : 'Í≥†Ï†ï';
});

document.getElementById('openSettingsBtn').addEventListener('click', () => {
    document.getElementById('settingsPanel').style.display = 'block';
    populateSettings();
});

document.getElementById('closeSettingsBtn').addEventListener('click', () => {
    document.getElementById('settingsPanel').style.display = 'none';
});

document.getElementById('applySettingsBtn').addEventListener('click', () => {
    applySettings();
    document.getElementById('settingsPanel').style.display = 'none';
});







function populateSettings() {
    console.log("populateSettings() - ÏÑ§Ï†ï Ìå®ÎÑê UI Î∞òÏòÅ ÏãúÏûë, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());

    document.getElementById('sceneStimulus').checked = gameState.stimulusTypes.includes('scene');
    document.getElementById('locationStimulus').checked = gameState.stimulusTypes.includes('location');
    document.getElementById('soundStimulus').checked = gameState.stimulusTypes.includes('sound');
    document.getElementById('colorStimulus').checked = gameState.stimulusTypes.includes('color');
    document.getElementById('stimuliPerBlock').value = gameState.stimuliPerBlock;
    document.getElementById('stimulusDuration').value = gameState.stimulusDuration;
    document.getElementById('stimulusInterval').value = gameState.stimulusInterval;
    document.getElementById('patternPreventionStrength').value = gameState.patternPreventionStrength;
    document.getElementById('minTargetInterval').value = gameState.minTargetInterval;
    document.getElementById('maxTargetInterval').value = gameState.maxTargetInterval;
    document.getElementById('nearMissProbability').value = gameState.nearMissProbability;
    document.getElementById('imageSourceUrl').value = gameState.imageSourceUrl;
    document.getElementById('resultImageUrl').value = gameState.resultImageUrl;
    document.getElementById('soundSourceSelect').value = gameState.soundSource;
    document.getElementById('soundSourceUrl').value = gameState.soundSourceUrl;
    document.getElementById('sceneKey').value = gameState.sceneKey;
    document.getElementById('locationKey').value = gameState.locationKey;
    document.getElementById('soundKey').value = gameState.soundKey;
    document.getElementById('colorKey').value = gameState.colorKey;
    document.getElementById('buttonBgColor').value = gameState.buttonStyles.bgColor;
    document.getElementById('buttonBgOpacity').value = gameState.buttonStyles.bgOpacity;
    document.getElementById('buttonTextColor').value = gameState.buttonStyles.textColor;
    document.getElementById('buttonTextOpacity').value = gameState.buttonStyles.textOpacity;
    document.getElementById('buttonWidth').value = gameState.buttonStyles.width;
    document.getElementById('buttonHeight').value = gameState.buttonStyles.height;

    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú UI Î∞òÏòÅ
    document.getElementById('randomizeInterval').checked = gameState.randomizeInterval;
    document.getElementById('minInterval').value = gameState.minInterval;
    document.getElementById('maxInterval').value = gameState.maxInterval;

    document.getElementById('button1Left').value = parseInt(sceneIndicator.style.left) || 20;
    document.getElementById('button1Bottom').value = parseInt(sceneIndicator.style.bottom) || 20;
    document.getElementById('button2Left').value = parseInt(soundIndicator.style.left) || 120;
    document.getElementById('button2Bottom').value = parseInt(soundIndicator.style.bottom) || 20;
    document.getElementById('button3Right').value = parseInt(locationIndicator.style.right) || 120;
    document.getElementById('button3Bottom').value = parseInt(locationIndicator.style.bottom) || 20;
    document.getElementById('button4Right').value = parseInt(colorIndicator.style.right) || 20;
    document.getElementById('button4Bottom').value = parseInt(colorIndicator.style.bottom) || 20;

    document.getElementById('useCeilingPanels').checked = gameState.useCeilingPanels;
    document.getElementById('useFloorPanels').checked = gameState.useFloorPanels;

    const ceilingPanel1 = gameState.panelPositionsCustom[8] || panelPositions[8] || { x: 0, y: 0, z: 0, rotation: [0, 0, 0] };
    document.getElementById('ceilingPanel1X').value = ceilingPanel1.x ?? 0;
    document.getElementById('ceilingPanel1Y').value = ceilingPanel1.y ?? 0;
    document.getElementById('ceilingPanel1Z').value = ceilingPanel1.z ?? 0;
    document.getElementById('ceilingPanel1RotX').value = ((ceilingPanel1.rotation?.[0] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('ceilingPanel1RotY').value = ((ceilingPanel1.rotation?.[1] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('ceilingPanel1RotZ').value = ((ceilingPanel1.rotation?.[2] ?? 0) * 180 / Math.PI).toFixed(1);

    const ceilingPanel2 = gameState.panelPositionsCustom[9] || panelPositions[9] || { x: 0, y: 0, z: 0, rotation: [0, 0, 0] };
    document.getElementById('ceilingPanel2X').value = ceilingPanel2.x ?? 0;
    document.getElementById('ceilingPanel2Y').value = ceilingPanel2.y ?? 0;
    document.getElementById('ceilingPanel2Z').value = ceilingPanel2.z ?? 0;
    document.getElementById('ceilingPanel2RotX').value = ((ceilingPanel2.rotation?.[0] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('ceilingPanel2RotY').value = ((ceilingPanel2.rotation?.[1] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('ceilingPanel2RotZ').value = ((ceilingPanel2.rotation?.[2] ?? 0) * 180 / Math.PI).toFixed(1);

    const floorPanel1 = gameState.panelPositionsCustom[10] || panelPositions[10] || { x: 0, y: 0, z: 0, rotation: [0, 0, 0] };
    document.getElementById('floorPanel1X').value = floorPanel1.x ?? 0;
    document.getElementById('floorPanel1Y').value = floorPanel1.y ?? 0;
    document.getElementById('floorPanel1Z').value = floorPanel1.z ?? 0;
    document.getElementById('floorPanel1RotX').value = ((floorPanel1.rotation?.[0] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('floorPanel1RotY').value = ((floorPanel1.rotation?.[1] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('floorPanel1RotZ').value = ((floorPanel1.rotation?.[2] ?? 0) * 180 / Math.PI).toFixed(1);

    const floorPanel2 = gameState.panelPositionsCustom[11] || panelPositions[11] || { x: 0, y: 0, z: 0, rotation: [0, 0, 0] };
    document.getElementById('floorPanel2X').value = floorPanel2.x ?? 0;
    document.getElementById('floorPanel2Y').value = floorPanel2.y ?? 0;
    document.getElementById('floorPanel2Z').value = floorPanel2.z ?? 0;
    document.getElementById('floorPanel2RotX').value = ((floorPanel2.rotation?.[0] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('floorPanel2RotY').value = ((floorPanel2.rotation?.[1] ?? 0) * 180 / Math.PI).toFixed(1);
    document.getElementById('floorPanel2RotZ').value = ((floorPanel2.rotation?.[2] ?? 0) * 180 / Math.PI).toFixed(1);

    console.log("populateSettings() - ÏÑ§Ï†ï Ìå®ÎÑêÏóê Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÏúÑÏπò Î∞òÏòÅ:", {
        scene: { left: document.getElementById('button1Left').value, bottom: document.getElementById('button1Bottom').value },
        sound: { left: document.getElementById('button2Left').value, bottom: document.getElementById('button2Bottom').value },
        location: { right: document.getElementById('button3Right').value, bottom: document.getElementById('button3Bottom').value },
        color: { right: document.getElementById('button4Right').value, bottom: document.getElementById('button4Bottom').value },
        timestamp: Date.now()
    });

    console.log("populateSettings() - Ìå®ÎÑê ÏÑ§Ï†ï UIÏóê Î∞òÏòÅ:", {
        useCeilingPanels: document.getElementById('useCeilingPanels').checked,
        useFloorPanels: document.getElementById('useFloorPanels').checked,
        ceilingPanel1: {
            x: document.getElementById('ceilingPanel1X').value,
            y: document.getElementById('ceilingPanel1Y').value,
            z: document.getElementById('ceilingPanel1Z').value,
            rotX: document.getElementById('ceilingPanel1RotX').value,
            rotY: document.getElementById('ceilingPanel1RotY').value,
            rotZ: document.getElementById('ceilingPanel1RotZ').value
        },
        ceilingPanel2: {
            x: document.getElementById('ceilingPanel2X').value,
            y: document.getElementById('ceilingPanel2Y').value,
            z: document.getElementById('ceilingPanel2Z').value,
            rotX: document.getElementById('ceilingPanel2RotX').value,
            rotY: document.getElementById('ceilingPanel2RotY').value,
            rotZ: document.getElementById('ceilingPanel2RotZ').value
        },
        floorPanel1: {
            x: document.getElementById('floorPanel1X').value,
            y: document.getElementById('floorPanel1Y').value,
            z: document.getElementById('floorPanel1Z').value,
            rotX: document.getElementById('floorPanel1RotX').value,
            rotY: document.getElementById('floorPanel1RotY').value,
            rotZ: document.getElementById('floorPanel1RotZ').value
        },
        floorPanel2: {
            x: document.getElementById('floorPanel2X').value,
            y: document.getElementById('floorPanel2Y').value,
            z: document.getElementById('floorPanel2Z').value,
            rotX: document.getElementById('floorPanel2RotX').value,
            rotY: document.getElementById('floorPanel2RotY').value,
            rotZ: document.getElementById('floorPanel2RotZ').value
        },
        timestamp: Date.now()
    });

    console.log("populateSettings() - panelPositionsCustom ÏÉÅÌÉú:", gameState.panelPositionsCustom);
    console.log("populateSettings() - UIÏóê ÏÑ§Ï†ïÍ∞í Î∞òÏòÅ ÏôÑÎ£å:", { 
        stimulusTypes: gameState.stimulusTypes,
        stimuliPerBlock: gameState.stimuliPerBlock,
        stimulusDuration: gameState.stimulusDuration,
        stimulusInterval: gameState.stimulusInterval,
        patternPreventionStrength: gameState.patternPreventionStrength,
        minTargetInterval: gameState.minTargetInterval,
        maxTargetInterval: gameState.maxTargetInterval,
        nearMissProbability: gameState.nearMissProbability,
        imageSourceUrl: gameState.imageSourceUrl,
        resultImageUrl: gameState.resultImageUrl,
        soundSource: gameState.soundSource,
        soundSourceUrl: gameState.soundSourceUrl,
        sceneKey: gameState.sceneKey,
        locationKey: gameState.locationKey,
        soundKey: gameState.soundKey,
        colorKey: gameState.colorKey,
        buttonStyles: gameState.buttonStyles,
        randomizeInterval: gameState.randomizeInterval,
        minInterval: gameState.minInterval,
        maxInterval: gameState.maxInterval,
        timestamp: Date.now()
    });

    let ceilingPanelsExist = false;
    let floorPanelsExist = false;
    panels.forEach(panel => {
        const index = panel.position;
        if (index >= 8 && index < 10) ceilingPanelsExist = true;
        if (index >= 10) floorPanelsExist = true;
    });

    console.log("populateSettings() - ÌòÑÏû¨ Ìå®ÎÑê ÏÉÅÌÉú ÌôïÏù∏:", {
        ceilingPanelsExist: ceilingPanelsExist,
        floorPanelsExist: floorPanelsExist,
        expectedCeilingPanels: gameState.useCeilingPanels,
        expectedFloorPanels: gameState.useFloorPanels
    });

    if (ceilingPanelsExist !== gameState.useCeilingPanels || floorPanelsExist !== gameState.useFloorPanels) {
        console.warn("populateSettings() - Ìå®ÎÑê ÏÉÅÌÉúÏôÄ ÏÑ§Ï†ïÍ∞í Î∂àÏùºÏπò, Ìå®ÎÑê Ïû¨ÏÉùÏÑ±ÏúºÎ°ú ÎèôÍ∏∞Ìôî");
        createPanels();
        console.log("populateSettings() - Ìå®ÎÑê Ïû¨ÏÉùÏÑ± ÏôÑÎ£å, ÎèôÍ∏∞Ìôî ÌõÑ Ìå®ÎÑê ÏÉÅÌÉú:", {
            ceilingPanelsExist: panels.some(panel => panel.position >= 8 && panel.position < 10),
            floorPanelsExist: panels.some(panel => panel.position >= 10)
        });
    } else {
        console.log("populateSettings() - Ìå®ÎÑê ÏÉÅÌÉúÏôÄ ÏÑ§Ï†ïÍ∞í ÏùºÏπò, ÎèôÍ∏∞Ìôî Î∂àÌïÑÏöî");
    }

    console.log("populateSettings() - ÏÑ§Ï†ï UI Î∞òÏòÅ Î∞è ÎèôÍ∏∞Ìôî ÏôÑÎ£å, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());
}






// Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïä§ÌÉÄÏùº Ï†ÅÏö©ÏùÑ ÏúÑÌïú ÌÜµÌï© Ìï®Ïàò
function applyIndicatorStyles(indicators, styles) {
    console.log("applyIndicatorStyles() - Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïä§ÌÉÄÏùº Ï†ÅÏö© ÏãúÏûë", { styles, timestamp: Date.now() });
    indicators.forEach((indicator, i) => {
        if (!indicator) {
            console.error(`applyIndicatorStyles() - Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ${i}Í∞Ä DOMÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå`);
            return;
        }
        const { bgColor, bgOpacity, textColor, textOpacity, width, height } = styles;
        indicator.style.backgroundColor = hexToRgba(bgColor, bgOpacity);
        indicator.style.color = hexToRgba(textColor, textOpacity);
        indicator.style.width = `${width}px`;
        indicator.style.height = `${height}px`;

        // Ï†ÅÏö©Îêú Ïä§ÌÉÄÏùº ÌôïÏù∏ Î°úÍ∑∏
        console.log(`applyIndicatorStyles() - Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ${i} Ïä§ÌÉÄÏùº Ï†ÅÏö© ÏôÑÎ£å`, {
            id: indicator.id,
            backgroundColor: indicator.style.backgroundColor,
            color: indicator.style.color,
            width: indicator.style.width,
            height: indicator.style.height
        });
    });
    console.log("applyIndicatorStyles() - Î™®Îì† Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïä§ÌÉÄÏùº Ï†ÅÏö© ÏôÑÎ£å");
}

















function applySettings() {
    console.log("applySettings() - ÏÑ§Ï†ï Ï†ÅÏö© ÏãúÏûë, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());

    const newStimulusTypes = [];
    if (document.getElementById('sceneStimulus').checked) newStimulusTypes.push('scene');
    if (document.getElementById('locationStimulus').checked) newStimulusTypes.push('location');
    if (document.getElementById('soundStimulus').checked) newStimulusTypes.push('sound');
    if (document.getElementById('colorStimulus').checked) newStimulusTypes.push('color');

    if (newStimulusTypes.length < 2 || newStimulusTypes.length > 4) {
        document.getElementById('settingsError').textContent = 'ÏûêÍ∑π Ïú†ÌòïÏùÄ ÏµúÏÜå 2Í∞ú, ÏµúÎåÄ 4Í∞ú ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§.';
        document.getElementById('settingsError').style.display = 'block';
        console.log("applySettings() - Ïò§Î•ò: ÏûêÍ∑π Ïú†Ìòï Í∞úÏàò Î∂ÄÏ†ÅÌï©:", newStimulusTypes);
        return;
    }

    const rawStimuliPerBlock = parseInt(document.getElementById('stimuliPerBlock').value, 10);
    const rawStimulusDuration = parseInt(document.getElementById('stimulusDuration').value, 10);
    const rawStimulusInterval = parseInt(document.getElementById('stimulusInterval').value, 10);
    const rawPatternPreventionStrength = parseInt(document.getElementById('patternPreventionStrength').value, 10);
    const rawMinTargetInterval = parseInt(document.getElementById('minTargetInterval').value, 10);
    const rawMaxTargetInterval = parseInt(document.getElementById('maxTargetInterval').value, 10);
    const rawNearMissProbability = parseFloat(document.getElementById('nearMissProbability').value);
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Í∞í
    const rawRandomizeInterval = document.getElementById('randomizeInterval').checked;
    const rawMinInterval = parseInt(document.getElementById('minInterval').value, 10);
    const rawMaxInterval = parseInt(document.getElementById('maxInterval').value, 10);

    console.log("applySettings() - UIÏóêÏÑú Í∞ÄÏ†∏Ïò® ÏõêÏãú Í∞í:", {
        rawStimuliPerBlock, rawStimulusDuration, rawStimulusInterval,
        rawPatternPreventionStrength, rawMinTargetInterval, rawMaxTargetInterval, rawNearMissProbability,
        rawRandomizeInterval, rawMinInterval, rawMaxInterval
    });

    gameState.stimulusTypes = newStimulusTypes;
    gameState.stimuliPerBlock = isNaN(rawStimuliPerBlock) ? 30 : Math.min(Math.max(rawStimuliPerBlock, 10), 100);
    gameState.stimulusDuration = isNaN(rawStimulusDuration) ? 1000 : Math.min(Math.max(rawStimulusDuration, 500), 5000);
    gameState.stimulusInterval = isNaN(rawStimulusInterval) ? 2500 : Math.min(Math.max(rawStimulusInterval, 1000), 10000);
    gameState.patternPreventionStrength = isNaN(rawPatternPreventionStrength) ? 5 : Math.min(Math.max(rawPatternPreventionStrength, 0), 10);
    gameState.minTargetInterval = isNaN(rawMinTargetInterval) ? 2 : Math.min(Math.max(rawMinTargetInterval, 1), 20);
    gameState.maxTargetInterval = isNaN(rawMaxTargetInterval) ? 10 : Math.min(Math.max(rawMaxTargetInterval, 5), 50);
    gameState.nearMissProbability = isNaN(rawNearMissProbability) ? 0.3 : Math.min(Math.max(rawNearMissProbability, 0), 1);
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÏÑ§Ï†ï Ï†ÅÏö©
    gameState.randomizeInterval = rawRandomizeInterval;
    gameState.minInterval = isNaN(rawMinInterval) ? 1000 : Math.min(Math.max(rawMinInterval, 1000), 10000);
    gameState.maxInterval = isNaN(rawMaxInterval) ? 2500 : Math.min(Math.max(rawMaxInterval, 1000), 10000);

    // ÏµúÏÜåÍ∞íÏù¥ ÏµúÎåÄÍ∞íÎ≥¥Îã§ ÌÅ∞ Í≤ΩÏö∞ Ï°∞Ï†ï
    if (gameState.minInterval > gameState.maxInterval) {
        gameState.maxInterval = gameState.minInterval;
        console.log("applySettings() - ÏµúÏÜå Í∞ÑÍ≤©Ïù¥ ÏµúÎåÄ Í∞ÑÍ≤©Î≥¥Îã§ Ïª§ ÏµúÎåÄÍ∞í Ï°∞Ï†ïÎê®:", gameState.maxInterval);
    }

    if (gameState.maxTargetInterval < gameState.minTargetInterval) {
        gameState.maxTargetInterval = gameState.minTargetInterval + 1;
        console.log("applySettings() - ÏµúÎåÄ ÌÉÄÍ≤ü Í∞ÑÍ≤© Ï°∞Ï†ïÎê®:", gameState.maxTargetInterval);
    }

    gameState.imageSourceUrl = document.getElementById('imageSourceUrl').value || 'images/';
    gameState.resultImageUrl = document.getElementById('resultImageUrl').value || '';
    gameState.soundSource = document.getElementById('soundSourceSelect').value || 'pianoTones';
    gameState.soundSourceUrl = document.getElementById('soundSourceUrl').value || 'sounds/';
    gameState.sceneKey = document.getElementById('sceneKey').value.toUpperCase() || 'S';
    gameState.locationKey = document.getElementById('locationKey').value.toUpperCase() || 'A';
    gameState.soundKey = document.getElementById('soundKey').value.toUpperCase() || 'L';
    gameState.colorKey = document.getElementById('colorKey').value.toUpperCase() || 'K';

    const bgColor = document.getElementById('buttonBgColor').value || '#ffffff';
    const bgOpacity = Math.min(Math.max(parseFloat(document.getElementById('buttonBgOpacity').value) || 0.1, 0), 1);
    const textColor = document.getElementById('buttonTextColor').value || '#ffffff';
    const textOpacity = Math.min(Math.max(parseFloat(document.getElementById('buttonTextOpacity').value) || 0.0, 0), 1);
    const width = Math.max(parseInt(document.getElementById('buttonWidth').value, 10) || 80, 20);
    const height = Math.max(parseInt(document.getElementById('buttonHeight').value, 10) || 80, 20);

    gameState.buttonStyles = { bgColor, bgOpacity, textColor, textOpacity, width, height };
    console.log("applySettings() - Î≤ÑÌäº Ïä§ÌÉÄÏùº Ï†ÅÏö©Îê®:", gameState.buttonStyles);

    const indicators = [sceneIndicator, soundIndicator, locationIndicator, colorIndicator];
    const indicatorPositions = [
        { left: parseInt(document.getElementById('button1Left').value) || 20, bottom: parseInt(document.getElementById('button1Bottom').value) || 20 },
        { left: parseInt(document.getElementById('button2Left').value) || 120, bottom: parseInt(document.getElementById('button2Bottom').value) || 20 },
        { right: parseInt(document.getElementById('button3Right').value) || 120, bottom: parseInt(document.getElementById('button3Bottom').value) || 20 },
        { right: parseInt(document.getElementById('button4Right').value) || 20, bottom: parseInt(document.getElementById('button4Bottom').value) || 20 }
    ];

    indicators.forEach((indicator, i) => {
        if (i < 2) {
            indicator.style.left = `${indicatorPositions[i].left}px`;
            indicator.style.right = '';
        } else {
            indicator.style.right = `${indicatorPositions[i].right}px`;
            indicator.style.left = '';
        }
        indicator.style.bottom = `${indicatorPositions[i].bottom}px`;
        console.log("applySettings() - Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÏúÑÏπò Ï†ÅÏö©:", {
            id: indicator.id,
            left: indicator.style.left,
            right: indicator.style.right,
            bottom: indicator.style.bottom
        });
    });

    applyIndicatorStyles(indicators, gameState.buttonStyles);

    const previousUseCeilingPanels = gameState.useCeilingPanels;
    const previousUseFloorPanels = gameState.useFloorPanels;
    gameState.useCeilingPanels = document.getElementById('useCeilingPanels').checked;
    gameState.useFloorPanels = document.getElementById('useFloorPanels').checked;

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const degToRad = (deg) => deg * Math.PI / 180;

    let ceilingPanel1X = parseFloat(document.getElementById('ceilingPanel1X').value);
    let ceilingPanel1Y = parseFloat(document.getElementById('ceilingPanel1Y').value);
    let ceilingPanel1Z = parseFloat(document.getElementById('ceilingPanel1Z').value);
    let ceilingPanel1RotX = parseFloat(document.getElementById('ceilingPanel1RotX').value);
    let ceilingPanel1RotY = parseFloat(document.getElementById('ceilingPanel1RotY').value);
    let ceilingPanel1RotZ = parseFloat(document.getElementById('ceilingPanel1RotZ').value);

    ceilingPanel1X = isNaN(ceilingPanel1X) ? panelPositions[8].x : clamp(ceilingPanel1X, -roomWidth / 2, roomWidth / 2);
    ceilingPanel1Y = isNaN(ceilingPanel1Y) ? panelPositions[8].y : clamp(ceilingPanel1Y, roomHeight - 1, roomHeight);
    ceilingPanel1Z = isNaN(ceilingPanel1Z) ? panelPositions[8].z : clamp(ceilingPanel1Z, -roomDepth / 2, roomDepth / 2);
    ceilingPanel1RotX = isNaN(ceilingPanel1RotX) ? panelPositions[8].rotation[0] * 180 / Math.PI : clamp(ceilingPanel1RotX, -180, 180);
    ceilingPanel1RotY = isNaN(ceilingPanel1RotY) ? panelPositions[8].rotation[1] * 180 / Math.PI : clamp(ceilingPanel1RotY, -180, 180);
    ceilingPanel1RotZ = isNaN(ceilingPanel1RotZ) ? panelPositions[8].rotation[2] * 180 / Math.PI : clamp(ceilingPanel1RotZ, -180, 180);

    gameState.panelPositionsCustom[8] = {
        x: ceilingPanel1X,
        y: ceilingPanel1Y,
        z: ceilingPanel1Z,
        rotation: [degToRad(ceilingPanel1RotX), degToRad(ceilingPanel1RotY), degToRad(ceilingPanel1RotZ)]
    };

    let ceilingPanel2X = parseFloat(document.getElementById('ceilingPanel2X').value);
    let ceilingPanel2Y = parseFloat(document.getElementById('ceilingPanel2Y').value);
    let ceilingPanel2Z = parseFloat(document.getElementById('ceilingPanel2Z').value);
    let ceilingPanel2RotX = parseFloat(document.getElementById('ceilingPanel2RotX').value);
    let ceilingPanel2RotY = parseFloat(document.getElementById('ceilingPanel2RotY').value);
    let ceilingPanel2RotZ = parseFloat(document.getElementById('ceilingPanel2RotZ').value);

    ceilingPanel2X = isNaN(ceilingPanel2X) ? panelPositions[9].x : clamp(ceilingPanel2X, -roomWidth / 2, roomWidth / 2);
    ceilingPanel2Y = isNaN(ceilingPanel2Y) ? panelPositions[9].y : clamp(ceilingPanel2Y, roomHeight - 1, roomHeight);
    ceilingPanel2Z = isNaN(ceilingPanel2Z) ? panelPositions[9].z : clamp(ceilingPanel2Z, -roomDepth / 2, roomDepth / 2);
    ceilingPanel2RotX = isNaN(ceilingPanel2RotX) ? panelPositions[9].rotation[0] * 180 / Math.PI : clamp(ceilingPanel2RotX, -180, 180);
    ceilingPanel2RotY = isNaN(ceilingPanel2RotY) ? panelPositions[9].rotation[1] * 180 / Math.PI : clamp(ceilingPanel2RotY, -180, 180);
    ceilingPanel2RotZ = isNaN(ceilingPanel2RotZ) ? panelPositions[9].rotation[2] * 180 / Math.PI : clamp(ceilingPanel2RotZ, -180, 180);

    gameState.panelPositionsCustom[9] = {
        x: ceilingPanel2X,
        y: ceilingPanel2Y,
        z: ceilingPanel2Z,
        rotation: [degToRad(ceilingPanel2RotX), degToRad(ceilingPanel2RotY), degToRad(ceilingPanel2RotZ)]
    };

    let floorPanel1X = parseFloat(document.getElementById('floorPanel1X').value);
    let floorPanel1Y = parseFloat(document.getElementById('floorPanel1Y').value);
    let floorPanel1Z = parseFloat(document.getElementById('floorPanel1Z').value);
    let floorPanel1RotX = parseFloat(document.getElementById('floorPanel1RotX').value);
    let floorPanel1RotY = parseFloat(document.getElementById('floorPanel1RotY').value);
    let floorPanel1RotZ = parseFloat(document.getElementById('floorPanel1RotZ').value);

    floorPanel1X = isNaN(floorPanel1X) ? panelPositions[10].x : clamp(floorPanel1X, -roomWidth / 2, roomWidth / 2);
    floorPanel1Y = isNaN(floorPanel1Y) ? panelPositions[10].y : clamp(floorPanel1Y, 0, 1);
    floorPanel1Z = isNaN(floorPanel1Z) ? panelPositions[10].z : clamp(floorPanel1Z, -roomDepth / 2, roomDepth / 2);
    floorPanel1RotX = isNaN(floorPanel1RotX) ? panelPositions[10].rotation[0] * 180 / Math.PI : clamp(floorPanel1RotX, -180, 180);
    floorPanel1RotY = isNaN(floorPanel1RotY) ? panelPositions[10].rotation[1] * 180 / Math.PI : clamp(floorPanel1RotY, -180, 180);
    floorPanel1RotZ = isNaN(floorPanel1RotZ) ? panelPositions[10].rotation[2] * 180 / Math.PI : clamp(floorPanel1RotZ, -180, 180);

    gameState.panelPositionsCustom[10] = {
        x: floorPanel1X,
        y: floorPanel1Y,
        z: floorPanel1Z,
        rotation: [degToRad(floorPanel1RotX), degToRad(floorPanel1RotY), degToRad(floorPanel1RotZ)]
    };

    let floorPanel2X = parseFloat(document.getElementById('floorPanel2X').value);
    let floorPanel2Y = parseFloat(document.getElementById('floorPanel2Y').value);
    let floorPanel2Z = parseFloat(document.getElementById('floorPanel2Z').value);
    let floorPanel2RotX = parseFloat(document.getElementById('floorPanel2RotX').value);
    let floorPanel2RotY = parseFloat(document.getElementById('floorPanel2RotY').value);
    let floorPanel2RotZ = parseFloat(document.getElementById('floorPanel2RotZ').value);

    floorPanel2X = isNaN(floorPanel2X) ? panelPositions[11].x : clamp(floorPanel2X, -roomWidth / 2, roomWidth / 2);
    floorPanel2Y = isNaN(floorPanel2Y) ? panelPositions[11].y : clamp(floorPanel2Y, 0, 1);
    floorPanel2Z = isNaN(floorPanel2Z) ? panelPositions[11].z : clamp(floorPanel2Z, -roomDepth / 2, roomDepth / 2);
    floorPanel2RotX = isNaN(floorPanel2RotX) ? panelPositions[11].rotation[0] * 180 / Math.PI : clamp(floorPanel2RotX, -180, 180);
    floorPanel2RotY = isNaN(floorPanel2RotY) ? panelPositions[11].rotation[1] * 180 / Math.PI : clamp(floorPanel2RotY, -180, 180);
    floorPanel2RotZ = isNaN(floorPanel2RotZ) ? panelPositions[11].rotation[2] * 180 / Math.PI : clamp(floorPanel2RotZ, -180, 180);

    gameState.panelPositionsCustom[11] = {
        x: floorPanel2X,
        y: floorPanel2Y,
        z: floorPanel2Z,
        rotation: [degToRad(floorPanel2RotX), degToRad(floorPanel2RotY), degToRad(floorPanel2RotZ)]
    };

    let ceilingPanelsExist = false;
    let floorPanelsExist = false;
    panels.forEach(panel => {
        const index = panel.position;
        if (index >= 8 && index < 10) ceilingPanelsExist = true;
        if (index >= 10) floorPanelsExist = true;
    });

    console.log("applySettings() - Ìå®ÎÑê ÏÉÅÌÉúÏôÄ ÏÑ§Ï†ïÍ∞í ÎπÑÍµê:", {
        previousCeilingPanels: previousUseCeilingPanels,
        previousFloorPanels: previousUseFloorPanels,
        newCeilingPanels: gameState.useCeilingPanels,
        newFloorPanels: gameState.useFloorPanels,
        ceilingPanelsExist: ceilingPanelsExist,
        floorPanelsExist: floorPanelsExist
    });

    const shouldRecreatePanels = 
        previousUseCeilingPanels !== gameState.useCeilingPanels ||
        previousUseFloorPanels !== gameState.useFloorPanels ||
        ceilingPanelsExist !== gameState.useCeilingPanels ||
        floorPanelsExist !== gameState.useFloorPanels;

    if (shouldRecreatePanels) {
        console.log("applySettings() - Ìå®ÎÑê ÏÑ§Ï†ï Î≥ÄÍ≤Ω ÎòêÎäî ÏÉÅÌÉú Î∂àÏùºÏπò, Ìå®ÎÑê Ïû¨ÏÉùÏÑ±");
        createPanels();
        console.log("applySettings() - Ìå®ÎÑê Ïû¨ÏÉùÏÑ± ÏôÑÎ£å, ÏÉàÎ°úÏö¥ Ìå®ÎÑê ÏÉÅÌÉú:", {
            ceilingPanelsExist: panels.some(panel => panel.position >= 8 && panel.position < 10),
            floorPanelsExist: panels.some(panel => panel.position >= 10)
        });
    } else {
        console.log("applySettings() - Ìå®ÎÑê ÏÑ§Ï†ï Î≥ÄÍ≤Ω ÏóÜÏùå, Ïû¨ÏÉùÏÑ± Î∂àÌïÑÏöî");
    }

    console.log("applySettings() - Ìå®ÎÑê ÏÑ§Ï†ï Ï†ÅÏö©Îê®:", {
        useCeilingPanels: gameState.useCeilingPanels,
        useFloorPanels: gameState.useFloorPanels,
        ceilingPanel1: gameState.panelPositionsCustom[8],
        ceilingPanel2: gameState.panelPositionsCustom[9],
        floorPanel1: gameState.panelPositionsCustom[10],
        floorPanel2: gameState.panelPositionsCustom[11],
        timestamp: Date.now()
    });

    // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû•
    localStorage.setItem('stimulusTypes', JSON.stringify(gameState.stimulusTypes));
    localStorage.setItem('stimuliPerBlock', gameState.stimuliPerBlock);
    localStorage.setItem('stimulusDuration', gameState.stimulusDuration);
    localStorage.setItem('stimulusInterval', gameState.stimulusInterval);
    localStorage.setItem('patternPreventionStrength', gameState.patternPreventionStrength);
    localStorage.setItem('minTargetInterval', gameState.minTargetInterval);
    localStorage.setItem('maxTargetInterval', gameState.maxTargetInterval);
    localStorage.setItem('nearMissProbability', gameState.nearMissProbability);
    localStorage.setItem('imageSourceUrl', gameState.imageSourceUrl);
    localStorage.setItem('resultImageUrl', gameState.resultImageUrl);
    localStorage.setItem('soundSource', gameState.soundSource);
    localStorage.setItem('soundSourceUrl', gameState.soundSourceUrl);
    localStorage.setItem('sceneKey', gameState.sceneKey);
    localStorage.setItem('locationKey', gameState.locationKey);
    localStorage.setItem('soundKey', gameState.soundKey);
    localStorage.setItem('colorKey', gameState.colorKey);
    localStorage.setItem('buttonStyles', JSON.stringify(gameState.buttonStyles));
    localStorage.setItem('sceneIndicatorPos', JSON.stringify({ left: indicatorPositions[0].left, bottom: indicatorPositions[0].bottom }));
    localStorage.setItem('soundIndicatorPos', JSON.stringify({ left: indicatorPositions[1].left, bottom: indicatorPositions[1].bottom }));
    localStorage.setItem('locationIndicatorPos', JSON.stringify({ right: indicatorPositions[2].right, bottom: indicatorPositions[2].bottom }));
    localStorage.setItem('colorIndicatorPos', JSON.stringify({ right: indicatorPositions[3].right, bottom: indicatorPositions[3].bottom }));
    localStorage.setItem('useCeilingPanels', gameState.useCeilingPanels);
    localStorage.setItem('useFloorPanels', gameState.useFloorPanels);
    localStorage.setItem('panelPositionsCustom', JSON.stringify(gameState.panelPositionsCustom));
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû•
    localStorage.setItem('randomizeInterval', gameState.randomizeInterval);
    localStorage.setItem('minInterval', gameState.minInterval);
    localStorage.setItem('maxInterval', gameState.maxInterval);

    console.log("applySettings() - Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•Îêú Í∞í:", {
        randomizeInterval: localStorage.getItem('randomizeInterval'),
        minInterval: localStorage.getItem('minInterval'),
        maxInterval: localStorage.getItem('maxInterval'),
        timestamp: Date.now()
    });

    console.log("applySettings() - ÏÑ§Ï†ï Ï†ÅÏö© Î∞è Ï†ÄÏû• ÏôÑÎ£å:", {
        stimulusTypes: gameState.stimulusTypes,
        stimuliPerBlock: gameState.stimuliPerBlock,
        stimulusDuration: gameState.stimulusDuration,
        stimulusInterval: gameState.stimulusInterval,
        nearMissProbability: gameState.nearMissProbability,
        buttonStyles: gameState.buttonStyles,
        randomizeInterval: gameState.randomizeInterval,
        minInterval: gameState.minInterval,
        maxInterval: gameState.maxInterval,
        timestamp: Date.now()
    });

    document.getElementById('settingsError').style.display = 'none';
    loadImageTextures();
}








function hexToRgba(hex, opacity) {
    let r = 0, g = 0, b = 0;
    if (hex.length === 7) {
        r = parseInt(hex.slice(1, 3), 16);
        g = parseInt(hex.slice(3, 5), 16);
        b = parseInt(hex.slice(5, 7), 16);
    }
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
}

function loadSettings() {
    console.log("loadSettings() - ÏÑ§Ï†ï Î°úÎìú ÏãúÏûë, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());

    const settingsWarning = document.getElementById('loadSettingsWarning');
    if (settingsWarning) {
        settingsWarning.style.display = 'none';
        settingsWarning.textContent = '';
    } else {
        console.warn("loadSettings() - Í≤ΩÍ≥† Î©îÏãúÏßÄ ÏöîÏÜå(loadSettingsWarning)Í∞Ä DOMÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå");
    }

    const savedNBackLevel = localStorage.getItem('nBackLevel');
    if (savedNBackLevel) {
        gameState.nBackLevel = Math.min(Math.max(parseInt(savedNBackLevel), 1), 9);
        document.getElementById('nBackLevel').textContent = gameState.nBackLevel;
        document.getElementById('customLevel').value = gameState.nBackLevel;
        console.log("loadSettings() - NÎ∞± Î†àÎ≤® Î°úÎìúÎê®:", gameState.nBackLevel);
    } else {
        console.log("loadSettings() - Ï†ÄÏû•Îêú NÎ∞± Î†àÎ≤® ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©:", gameState.nBackLevel);
    }

    // UTC Í∏∞Ï§ÄÏúºÎ°ú ÎÇ†Ïßú Í≤ΩÍ≥Ñ ÌôïÏù∏
    const now = Date.now();
    const todayStart = new Date(new Date().setUTCHours(0, 0, 0, 0)).getTime();
    const lastGameTimestamp = parseInt(localStorage.getItem('lastGameTimestamp')) || 0;
    console.log("loadSettings() - ÎÇ†Ïßú Í≤ΩÍ≥Ñ ÎπÑÍµê: Ïò§Îäò ÏãúÏûë=", todayStart, "ÎßàÏßÄÎßâ Í≤åÏûÑ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ=", lastGameTimestamp);

    if (lastGameTimestamp < todayStart) {
        gameState.totalGamesToday = 0;
        gameState.consecutiveGames = 0;
        localStorage.setItem('lastGameTimestamp', now.toString());
        console.log("loadSettings() - ÎÇ†Ïßú Í≤ΩÍ≥Ñ ÎÑòÏñ¥Í∞ê, Ïπ¥Ïö¥ÌÑ∞ Ï¥àÍ∏∞Ìôî: totalGamesToday=", gameState.totalGamesToday, "consecutiveGames=", gameState.consecutiveGames);
    } else {
        const savedTotalGames = localStorage.getItem('totalGamesToday');
        const savedConsecutiveGames = localStorage.getItem('consecutiveGames');
        gameState.totalGamesToday = savedTotalGames ? parseInt(savedTotalGames) : 0;
        gameState.consecutiveGames = savedConsecutiveGames ? parseInt(savedConsecutiveGames) : 0;
        console.log("loadSettings() - Í∞ôÏùÄ ÎÇ†Ïßú ÎÇ¥, Ïπ¥Ïö¥ÌÑ∞ Î°úÎìúÎê®: totalGamesToday=", gameState.totalGamesToday, "consecutiveGames=", gameState.consecutiveGames);
    }
    updateGameCounters(); // ÌÜµÌï©Îêú Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò Ìò∏Ï∂ú

    const savedStimulusTypes = JSON.parse(localStorage.getItem('stimulusTypes'));
    gameState.stimulusTypes = (savedStimulusTypes && savedStimulusTypes.length >= 2 && savedStimulusTypes.length <= 4) ? savedStimulusTypes : ['scene', 'location'];
    console.log("loadSettings() - ÏûêÍ∑π Ïú†Ìòï Î°úÎìúÎê®:", gameState.stimulusTypes);

    const savedStimuliPerBlock = parseInt(localStorage.getItem('stimuliPerBlock'));
    gameState.stimuliPerBlock = isNaN(savedStimuliPerBlock) ? 30 : Math.min(Math.max(savedStimuliPerBlock, 10), 100);
    console.log("loadSettings() - Î∏îÎ°ùÎãπ ÏûêÍ∑π Ïàò Î°úÎìúÎê®:", gameState.stimuliPerBlock);

    const savedStimulusDuration = parseInt(localStorage.getItem('stimulusDuration'));
    gameState.stimulusDuration = isNaN(savedStimulusDuration) ? 1000 : Math.min(Math.max(savedStimulusDuration, 500), 5000);
    console.log("loadSettings() - ÏûêÍ∑π ÏßÄÏÜç ÏãúÍ∞Ñ Î°úÎìúÎê®:", gameState.stimulusDuration);

    const savedStimulusInterval = parseInt(localStorage.getItem('stimulusInterval'));
    gameState.stimulusInterval = isNaN(savedStimulusInterval) ? 2500 : Math.min(Math.max(savedStimulusInterval, 1000), 10000);
    console.log("loadSettings() - ÏûêÍ∑π Í∞ÑÍ≤© Î°úÎìúÎê®:", gameState.stimulusInterval);

    const savedPatternPreventionStrength = parseInt(localStorage.getItem('patternPreventionStrength'));
    gameState.patternPreventionStrength = isNaN(savedPatternPreventionStrength) ? 5 : Math.min(Math.max(savedPatternPreventionStrength, 0), 10);
    console.log("loadSettings() - Ìå®ÌÑ¥ Î∞©ÏßÄ Í∞ïÎèÑ Î°úÎìúÎê®:", gameState.patternPreventionStrength);

    const savedMinTargetInterval = parseInt(localStorage.getItem('minTargetInterval'));
    gameState.minTargetInterval = isNaN(savedMinTargetInterval) ? 2 : Math.min(Math.max(savedMinTargetInterval, 1), 20);
    console.log("loadSettings() - ÏµúÏÜå ÌÉÄÍ≤ü Í∞ÑÍ≤© Î°úÎìúÎê®:", gameState.minTargetInterval);

    const savedMaxTargetInterval = parseInt(localStorage.getItem('maxTargetInterval'));
    gameState.maxTargetInterval = isNaN(savedMaxTargetInterval) ? 10 : Math.min(Math.max(savedMaxTargetInterval, 5), 50);
    console.log("loadSettings() - ÏµúÎåÄ ÌÉÄÍ≤ü Í∞ÑÍ≤© Î°úÎìúÎê®:", gameState.maxTargetInterval);

    const savedNearMissProbability = parseFloat(localStorage.getItem('nearMissProbability'));
    gameState.nearMissProbability = isNaN(savedNearMissProbability) ? 0.3 : Math.min(Math.max(savedNearMissProbability, 0), 1);
    console.log("loadSettings() - Í∑ºÏ†ë Ïò§Ï∞® ÌôïÎ•† Î°úÎìúÎê®:", gameState.nearMissProbability);

    const savedRandomizeInterval = localStorage.getItem('randomizeInterval');
    gameState.randomizeInterval = savedRandomizeInterval === 'true' || savedRandomizeInterval === true;
    const savedMinInterval = parseInt(localStorage.getItem('minInterval'));
    gameState.minInterval = isNaN(savedMinInterval) ? 2500 : Math.min(Math.max(savedMinInterval, 1000), 10000);
    const savedMaxInterval = parseInt(localStorage.getItem('maxInterval'));
    gameState.maxInterval = isNaN(savedMaxInterval) ? 2500 : Math.min(Math.max(savedMaxInterval, 1000), 10000);

    if (gameState.minInterval > gameState.maxInterval) {
        gameState.maxInterval = gameState.minInterval;
        console.log("loadSettings() - ÏµúÏÜå Í∞ÑÍ≤©Ïù¥ ÏµúÎåÄ Í∞ÑÍ≤©Î≥¥Îã§ Ïª§ ÏµúÎåÄÍ∞í Ï°∞Ï†ïÎê®:", gameState.maxInterval);
    }

    console.log("loadSettings() - Î¨¥ÏûëÏúÑ Í∞ÑÍ≤© ÏÑ§Ï†ï Î°úÎìúÎê®:", {
        randomizeInterval: gameState.randomizeInterval,
        minInterval: gameState.minInterval,
        maxInterval: gameState.maxInterval
    });

    if (gameState.maxTargetInterval < gameState.minTargetInterval) {
        gameState.maxTargetInterval = gameState.minTargetInterval + 1;
        console.log("loadSettings() - Í≤ΩÍ≥†: ÏµúÎåÄ ÌÉÄÍ≤ü Í∞ÑÍ≤©Ïù¥ ÏµúÏÜå Í∞ÑÍ≤©Î≥¥Îã§ ÏûëÏïÑ Ï°∞Ï†ïÎê®:", gameState.maxTargetInterval);
    }

    const rawUseCeilingPanels = localStorage.getItem('useCeilingPanels');
    const rawUseFloorPanels = localStorage.getItem('useFloorPanels');

    console.log("loadSettings() - Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Î°úÎìúÎêú ÏõêÏãú Ìå®ÎÑê ÏÑ§Ï†ï Í∞í:", {
        rawUseCeilingPanels: rawUseCeilingPanels,
        rawUseFloorPanels: rawUseFloorPanels
    });

    gameState.useCeilingPanels = rawUseCeilingPanels === 'true' || rawUseCeilingPanels === true;
    gameState.useFloorPanels = rawUseFloorPanels === 'true' || rawUseFloorPanels === true;

    let hasInvalidSettings = false;
    if (rawUseCeilingPanels !== 'true' && rawUseCeilingPanels !== 'false' && rawUseCeilingPanels !== null) {
        console.warn("loadSettings() - useCeilingPanels Í∞íÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå, Í∏∞Î≥∏Í∞í(false)ÏúºÎ°ú Ï¥àÍ∏∞Ìôî:", rawUseCeilingPanels);
        gameState.useCeilingPanels = false;
        localStorage.setItem('useCeilingPanels', 'false');
        hasInvalidSettings = true;
    }
    if (rawUseFloorPanels !== 'true' && rawUseFloorPanels !== 'false' && rawUseFloorPanels !== null) {
        console.warn("loadSettings() - useFloorPanels Í∞íÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå, Í∏∞Î≥∏Í∞í(false)ÏúºÎ°ú Ï¥àÍ∏∞Ìôî:", rawUseFloorPanels);
        gameState.useFloorPanels = false;
        localStorage.setItem('useFloorPanels', 'false');
        hasInvalidSettings = true;
    }

    if (hasInvalidSettings && settingsWarning) {
        settingsWarning.textContent = 'ÏùºÎ∂Ä ÏÑ§Ï†ïÍ∞íÏù¥ ÏÜêÏÉÅÎêòÏñ¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.';
        settingsWarning.style.display = 'block';
        console.log("loadSettings() - ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏÑ§Ï†ï ÏÜêÏÉÅ Í≤ΩÍ≥† ÌëúÏãú");
    }

    console.log("loadSettings() - Ìå®ÎÑê ÏÑ§Ï†ï Î°úÎìú ÌõÑ ÏÉÅÌÉú:", {
        useCeilingPanels: gameState.useCeilingPanels,
        useFloorPanels: gameState.useFloorPanels
    });

    gameState.panelPositionsCustom = JSON.parse(localStorage.getItem('panelPositionsCustom')) || panelPositions.map(pos => ({
        x: pos.x,
        y: pos.y,
        z: pos.z,
        rotation: pos.rotation || [0, 0, 0]
    }));

    if (!Array.isArray(gameState.panelPositionsCustom) || gameState.panelPositionsCustom.length !== panelPositions.length) {
        console.warn("loadSettings() - panelPositionsCustomÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå, Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞Ìôî");
        gameState.panelPositionsCustom = panelPositions.map(pos => ({
            x: pos.x,
            y: pos.y,
            z: pos.z,
            rotation: pos.rotation || [0, 0, 0]
        }));
        hasInvalidSettings = true;
    }

    gameState.panelPositionsCustom = gameState.panelPositionsCustom.map((pos, index) => ({
        x: pos.x,
        y: pos.y,
        z: pos.z,
        rotation: pos.rotation || panelPositions[index]?.rotation || [0, 0, 0]
    }));

    gameState.imageSourceUrl = localStorage.getItem('imageSourceUrl') || 'images/';
    gameState.resultImageUrl = localStorage.getItem('resultImageUrl') || '';
    gameState.soundSource = localStorage.getItem('soundSource') || 'pianoTones';
    gameState.soundSourceUrl = localStorage.getItem('soundSourceUrl') || 'sounds/';
    gameState.sceneKey = localStorage.getItem('sceneKey') || 'S';
    gameState.locationKey = localStorage.getItem('locationKey') || 'A';
    gameState.soundKey = localStorage.getItem('soundKey') || 'L';
    gameState.colorKey = localStorage.getItem('colorKey') || 'K';
    console.log("loadSettings() - URL Î∞è ÌÇ§ ÏÑ§Ï†ï Î°úÎìúÎê®:", {
        imageSourceUrl: gameState.imageSourceUrl,
        resultImageUrl: gameState.resultImageUrl,
        soundSource: gameState.soundSource,
        soundSourceUrl: gameState.soundSourceUrl,
        sceneKey: gameState.sceneKey,
        locationKey: gameState.locationKey,
        soundKey: gameState.soundKey,
        colorKey: gameState.colorKey
    });

    const scenePos = JSON.parse(localStorage.getItem('sceneIndicatorPos')) || { left: 20, bottom: 20 };
    const soundPos = JSON.parse(localStorage.getItem('soundIndicatorPos')) || { left: 120, bottom: 20 };
    const locationPos = JSON.parse(localStorage.getItem('locationIndicatorPos')) || { right: 120, bottom: 20 };
    const colorPos = JSON.parse(localStorage.getItem('colorIndicatorPos')) || { right: 20, bottom: 20 };

    sceneIndicator.style.left = `${scenePos.left}px`;
    sceneIndicator.style.bottom = `${scenePos.bottom}px`;
    sceneIndicator.style.right = '';
    soundIndicator.style.left = `${soundPos.left}px`;
    soundIndicator.style.bottom = `${soundPos.bottom}px`;
    soundIndicator.style.right = '';
    locationIndicator.style.right = `${locationPos.right}px`;
    locationIndicator.style.bottom = `${locationPos.bottom}px`;
    locationIndicator.style.left = '';
    colorIndicator.style.right = `${colorPos.right}px`;
    colorIndicator.style.bottom = `${colorPos.bottom}px`;
    colorIndicator.style.left = '';

    console.log("loadSettings() - Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÏúÑÏπò Î°úÎìú Î∞è Ï†ÅÏö©:", {
        scene: { left: sceneIndicator.style.left, bottom: sceneIndicator.style.bottom },
        sound: { left: soundIndicator.style.left, bottom: soundIndicator.style.bottom },
        location: { right: locationIndicator.style.right, bottom: locationIndicator.style.bottom },
        color: { right: colorIndicator.style.right, bottom: colorIndicator.style.bottom }
    });

    gameState.buttonStyles = JSON.parse(localStorage.getItem('buttonStyles')) || {
        bgColor: '#ffffff',
        bgOpacity: 0.1,
        textColor: '#ffffff',
        textOpacity: 0.0,
        width: 80,
        height: 80
    };
    console.log("loadSettings() - Î≤ÑÌäº Ïä§ÌÉÄÏùº Î°úÎìúÎê®:", gameState.buttonStyles);

    const indicators = [sceneIndicator, soundIndicator, locationIndicator, colorIndicator];
    applyIndicatorStyles(indicators, gameState.buttonStyles);

    console.log("loadSettings() - Î™®Îì† ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å:", {
        stimulusTypes: gameState.stimulusTypes,
        stimuliPerBlock: gameState.stimuliPerBlock,
        stimulusDuration: gameState.stimulusDuration,
        stimulusInterval: gameState.stimulusInterval,
        patternPreventionStrength: gameState.patternPreventionStrength,
        minTargetInterval: gameState.minTargetInterval,
        maxTargetInterval: gameState.maxTargetInterval,
        nearMissProbability: gameState.nearMissProbability,
        useCeilingPanels: gameState.useCeilingPanels,
        useFloorPanels: gameState.useFloorPanels,
        panelPositionsCustom: gameState.panelPositionsCustom,
        randomizeInterval: gameState.randomizeInterval,
        minInterval: gameState.minInterval,
        maxInterval: gameState.maxInterval,
        timestamp: Date.now()
    });

    populateSettings();
    console.log("loadSettings() - ÏÑ§Ï†ï Î°úÎìú Î∞è UI Î∞òÏòÅ ÏôÑÎ£å, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", Date.now());
}










window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log("window.onresize - Î∑∞Ìè¨Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏: width:", window.innerWidth, "height:", window.innerHeight);
    renderer.render(scene, camera); // Ï¶âÏãú Î†åÎçîÎßÅ Ìò∏Ï∂ú
});

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    document.getElementById('fullscreenGuide').style.display = 'block';
    console.log("ÏïÑÏù¥Ìè∞ Í∞êÏßÄ - Ï†ÑÏ≤¥ÌôîÎ©¥ ÏïàÎÇ¥ ÌëúÏãú");
}

document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM fully loaded at timestamp:", Date.now());
    console.log("Initial DOM check:", {
        titleScreen: document.getElementById('titleScreen') ? "Found" : "Missing",
        gameScreen: document.getElementById('gameScreen') ? "Found" : "Missing",
        blockCount: document.getElementById('blockCount') ? "Found" : "Missing"
    });
});

window.onload = () => {
    console.log("Window fully loaded (including resources) at timestamp:", Date.now());
    loadImageTextures().then(() => {
        console.log("window.onload - Ïù¥ÎØ∏ÏßÄ Î°úÎìú ÏôÑÎ£å, ÏÑ§Ï†ï Î°úÎìú ÏãúÏûë");
        loadSettings();
        console.log("window.onload - ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å, Ìå®ÎÑê ÏÉùÏÑ± ÏãúÏûë");
        createPanels(); // ÏÑ§Ï†ï Î°úÎìú ÌõÑ Ìå®ÎÑê ÏÉùÏÑ±
        console.log("window.onload - Ìå®ÎÑê ÏÉùÏÑ± ÏôÑÎ£å, Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë");
        animate();

        // Í≥†Í∏â ÏÑ§Ï†ï ÌÜ†Í∏Ä Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        const toggleAdvancedSettingsBtn = document.getElementById('toggleAdvancedSettingsBtn');
        if (toggleAdvancedSettingsBtn) {
            toggleAdvancedSettingsBtn.addEventListener('click', () => {
                const advancedSettings = document.getElementById('advancedSettings');
                if (advancedSettings) {
                    advancedSettings.style.display = advancedSettings.style.display === 'none' ? 'block' : 'none';
                    console.log("toggleAdvancedSettingsBtn clicked - Advanced settings visibility:", advancedSettings.style.display);
                } else {
                    console.error("advancedSettings element not found in DOM");
                }
            });
            console.log("toggleAdvancedSettingsBtn event listener added successfully");
        } else {
            console.error("toggleAdvancedSettingsBtn not found in DOM at window.onload");
        }

        // Î≤ÑÌäº ÏÑ§Ï†ï ÌÜ†Í∏Ä Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        const toggleButtonSettingsBtn = document.getElementById('toggleButtonSettingsBtn');
        if (toggleButtonSettingsBtn) {
            toggleButtonSettingsBtn.addEventListener('click', () => {
                const buttonSettings = document.getElementById('buttonSettings');
                if (buttonSettings) {
                    buttonSettings.style.display = buttonSettings.style.display === 'none' ? 'block' : 'none';
                    console.log("toggleButtonSettingsBtn clicked - Button settings visibility:", buttonSettings.style.display);
                } else {
                    console.error("buttonSettings element not found in DOM");
                }
            });
            console.log("toggleButtonSettingsBtn event listener added successfully");
        } else {
            console.error("toggleButtonSettingsBtn not found in DOM at window.onload");
        }

        // Ìå®ÎÑê ÏÑ§Ï†ï ÌÜ†Í∏Ä Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        const togglePanelSettingsBtn = document.getElementById('togglePanelSettingsBtn');
        if (togglePanelSettingsBtn) {
            togglePanelSettingsBtn.addEventListener('click', () => {
                const panelSettings = document.getElementById('panelSettings');
                if (panelSettings) {
                    panelSettings.style.display = panelSettings.style.display === 'none' ? 'block' : 'none';
                    console.log("togglePanelSettingsBtn clicked - Panel settings visibility:", panelSettings.style.display);
                } else {
                    console.error("panelSettings element not found in DOM");
                }
            });
            console.log("togglePanelSettingsBtn event listener added successfully");
        } else {
            console.error("togglePanelSettingsBtn not found in DOM at window.onload");
        }

        // ÏÑ§Ï†ï Ìå®ÎÑê Îã´Í∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        if (closeSettingsBtn) {
            closeSettingsBtn.addEventListener('click', () => {
                const settingsPanel = document.getElementById('settingsPanel');
                const advancedSettings = document.getElementById('advancedSettings');
                const buttonSettings = document.getElementById('buttonSettings');
                const panelSettings = document.getElementById('panelSettings');
                if (settingsPanel) {
                    settingsPanel.style.display = 'none';
                    console.log("closeSettingsBtn clicked - Settings panel closed");
                } else {
                    console.error("settingsPanel not found in DOM");
                }
                if (advancedSettings) {
                    advancedSettings.style.display = 'none';
                    console.log("closeSettingsBtn clicked - Advanced settings hidden");
                }
                if (buttonSettings) {
                    buttonSettings.style.display = 'none';
                    console.log("closeSettingsBtn clicked - Button settings hidden");
                }
                if (panelSettings) {
                    panelSettings.style.display = 'none';
                    console.log("closeSettingsBtn clicked - Panel settings hidden");
                }
            });
            console.log("closeSettingsBtn event listener added successfully");
        } else {
            console.error("closeSettingsBtn not found in DOM at window.onload");
        }
    }).catch(err => {
        console.error("window.onload - Ïù¥ÎØ∏ÏßÄ Î°úÎî© Ï§ë Ïò§Î•ò Î∞úÏÉù:", err);
    });
};
